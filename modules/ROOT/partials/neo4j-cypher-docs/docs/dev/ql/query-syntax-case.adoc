[[query-syntax-case]]
= `CASE` expressions

Generic conditional expressions may be expressed using the well-known `CASE` construct.
Two variants of `CASE` exist within Cypher: the simple form, which allows an expression to be compared against multiple values, and the generic form, which allows multiple conditional statements to be expressed.

The following graph is used for the examples below:

.Graph
["dot", "`CASE` expressions-1.svg", "neoviz", ""]
----
  N0 [
    label = "{A|name = \'Alice\'\lage = 38\leyes = \'brown\'\l}"
  ]
  N0 -> N2 [
    color = "#2e3436"
    fontcolor = "#2e3436"
    label = "KNOWS\n"
  ]
  N0 -> N1 [
    color = "#2e3436"
    fontcolor = "#2e3436"
    label = "KNOWS\n"
  ]
  N1 [
    label = "{B|name = \'Bob\'\lage = 25\leyes = \'blue\'\l}"
  ]
  N1 -> N3 [
    color = "#2e3436"
    fontcolor = "#2e3436"
    label = "KNOWS\n"
  ]
  N1 -> N4 [
    color = "#4e9a06"
    fontcolor = "#4e9a06"
    label = "MARRIED\n"
  ]
  N2 [
    label = "{C|name = \'Charlie\'\lage = 53\leyes = \'green\'\l}"
  ]
  N2 -> N3 [
    color = "#2e3436"
    fontcolor = "#2e3436"
    label = "KNOWS\n"
  ]
  N3 [
    label = "{D|name = \'Daniel\'\leyes = \'brown\'\l}"
  ]
  N4 [
    label = "{E|eyes = \'blue\'\larray = \[\'one\', \'two\', \'three\'\]\lname = \'Eskil\'\lage = 41\l}"
  ]

----
 

[[syntax-simple-case]]
== Simple `CASE` form: comparing an expression against multiple values

The expression is calculated, and compared in order with the `WHEN` clauses until a match is found.
If no match is found, the expression in the `ELSE` clause is returned.
However, if there is no `ELSE` case and no match is found, `null` will be returned.


*Syntax:*
[source, cypher, role=noplay]
CASE test
  WHEN value THEN result
  [WHEN ...]
  [ELSE default]
END



*Arguments:*
[options="header"]
|===
| Name | Description
| `test` | A valid expression.
| `value` | An expression whose result will be compared to `test`.
| `result` | This is the expression returned as output if `value` matches `test`.
| `default` | If no match is found, `default` is returned.
|===


.Query
[source, cypher]
----
MATCH (n)
RETURN
CASE n.eyes
  WHEN 'blue'  THEN 1
  WHEN 'brown' THEN 2
  ELSE 3
END AS result
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +result+
| +2+
| +1+
| +3+
| +2+
| +1+
1+d|Rows: 5
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE
  (alice:A {name:'Alice', age: 38, eyes: 'brown'}),
  (bob:B {name: 'Bob', age: 25, eyes: 'blue'}),
  (charlie:C {name: 'Charlie', age: 53, eyes: 'green'}),
  (daniel:D {name: 'Daniel', eyes: 'brown'}),
  (eskil:E {name: 'Eskil', age: 41, eyes: 'blue', array: ['one', 'two', 'three']}),
  (alice)-[:KNOWS]->(bob),
  (alice)-[:KNOWS]->(charlie),
  (bob)-[:KNOWS]->(daniel),
  (charlie)-[:KNOWS]->(daniel),
  (bob)-[:MARRIED]->(eskil)

]]></database><command><![CDATA[
MATCH (n)
RETURN
CASE n.eyes
  WHEN 'blue'  THEN 1
  WHEN 'brown' THEN 2
  ELSE 3
END AS result
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[syntax-generic-case]]
== Generic `CASE` form: allowing for multiple conditionals to be expressed

The predicates are evaluated in order until a `true` value is found, and the result value is used.
If no match is found, the expression in the `ELSE` clause is returned.
However, if there is no `ELSE` case and no match is found, `null` will be returned.


*Syntax:*
[source, cypher, role=noplay]
CASE
  WHEN predicate THEN result
  [WHEN ...]
  [ELSE default]
END



*Arguments:*
[options="header"]
|===
| Name | Description
| `predicate` | A predicate that is tested to find a valid alternative.
| `result` | This is the expression returned as output if `predicate` evaluates to `true`.
| `default` | If no match is found, `default` is returned.
|===


.Query
[source, cypher]
----
MATCH (n)
RETURN
CASE
  WHEN n.eyes = 'blue' THEN 1
  WHEN n.age < 40      THEN 2
  ELSE 3
END AS result
----

.Result
[role="queryresult",options="header,footer",cols="1*<m"]
|===
| +result+
| +2+
| +1+
| +3+
| +3+
| +1+
1+d|Rows: 5
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE
  (alice:A {name:'Alice', age: 38, eyes: 'brown'}),
  (bob:B {name: 'Bob', age: 25, eyes: 'blue'}),
  (charlie:C {name: 'Charlie', age: 53, eyes: 'green'}),
  (daniel:D {name: 'Daniel', eyes: 'brown'}),
  (eskil:E {name: 'Eskil', age: 41, eyes: 'blue', array: ['one', 'two', 'three']}),
  (alice)-[:KNOWS]->(bob),
  (alice)-[:KNOWS]->(charlie),
  (bob)-[:KNOWS]->(daniel),
  (charlie)-[:KNOWS]->(daniel),
  (bob)-[:MARRIED]->(eskil)

]]></database><command><![CDATA[
MATCH (n)
RETURN
CASE
  WHEN n.eyes = 'blue' THEN 1
  WHEN n.age < 40      THEN 2
  ELSE 3
END AS result
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

[[syntax-distinguish-case]]
== Distinguishing between when to use the simple and generic `CASE` forms

Owing to the close similarity between the syntax of the two forms, sometimes it may not be clear at the outset as to which form to use.
We illustrate this scenario by means of the following query, in which there is an expectation that `age_10_years_ago` is `-1` if `n.age` is `null`:
        


.Query
[source, cypher]
----
MATCH (n)
RETURN n.name,
CASE n.age
  WHEN n.age IS NULL THEN -1
  ELSE n.age - 10
END AS age_10_years_ago
----

However, as this query is written using the simple `CASE` form, instead of `age_10_years_ago` being `-1` for the node named `Daniel`, it is `null`.
This is because a comparison is made between `n.age` and `n.age IS NULL`.
As `n.age IS NULL` is a boolean value, and `n.age` is an integer value, the `WHEN n.age IS NULL THEN -1` branch is never taken.
This results in the `ELSE n.age - 10` branch being taken instead, returning `null`.

.Result
[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +n.name+ | +age_10_years_ago+
| +"Alice"+ | +28+
| +"Bob"+ | +15+
| +"Charlie"+ | +43+
| +"Daniel"+ | +<null>+
| +"Eskil"+ | +31+
2+d|Rows: 5
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE
  (alice:A {name:'Alice', age: 38, eyes: 'brown'}),
  (bob:B {name: 'Bob', age: 25, eyes: 'blue'}),
  (charlie:C {name: 'Charlie', age: 53, eyes: 'green'}),
  (daniel:D {name: 'Daniel', eyes: 'brown'}),
  (eskil:E {name: 'Eskil', age: 41, eyes: 'blue', array: ['one', 'two', 'three']}),
  (alice)-[:KNOWS]->(bob),
  (alice)-[:KNOWS]->(charlie),
  (bob)-[:KNOWS]->(daniel),
  (charlie)-[:KNOWS]->(daniel),
  (bob)-[:MARRIED]->(eskil)

]]></database><command><![CDATA[
MATCH (n)
RETURN n.name,
CASE n.age
  WHEN n.age IS NULL THEN -1
  ELSE n.age - 10
END AS age_10_years_ago
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

The corrected query, behaving as expected, is given by the following generic `CASE` form:


.Query
[source, cypher]
----
MATCH (n)
RETURN n.name,
CASE
  WHEN n.age IS NULL THEN -1
  ELSE n.age - 10
END AS age_10_years_ago
----

We now see that the `age_10_years_ago` correctly returns `-1` for the node named `Daniel`.

.Result
[role="queryresult",options="header,footer",cols="2*<m"]
|===
| +n.name+ | +age_10_years_ago+
| +"Alice"+ | +28+
| +"Bob"+ | +15+
| +"Charlie"+ | +43+
| +"Daniel"+ | +-1+
| +"Eskil"+ | +31+
2+d|Rows: 5
|===

ifndef::nonhtmloutput[]
[subs="none"]
++++
<formalpara role="cypherconsole">
<title>Try this query live</title>
<para><database><![CDATA[
CREATE
  (alice:A {name:'Alice', age: 38, eyes: 'brown'}),
  (bob:B {name: 'Bob', age: 25, eyes: 'blue'}),
  (charlie:C {name: 'Charlie', age: 53, eyes: 'green'}),
  (daniel:D {name: 'Daniel', eyes: 'brown'}),
  (eskil:E {name: 'Eskil', age: 41, eyes: 'blue', array: ['one', 'two', 'three']}),
  (alice)-[:KNOWS]->(bob),
  (alice)-[:KNOWS]->(charlie),
  (bob)-[:KNOWS]->(daniel),
  (charlie)-[:KNOWS]->(daniel),
  (bob)-[:MARRIED]->(eskil)

]]></database><command><![CDATA[
MATCH (n)
RETURN n.name,
CASE
  WHEN n.age IS NULL THEN -1
  ELSE n.age - 10
END AS age_10_years_ago
]]></command></para></formalpara>
++++
endif::nonhtmloutput[]

