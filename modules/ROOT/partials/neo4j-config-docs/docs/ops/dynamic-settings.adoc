// tag::reference-dynamic-settings-reference[]
[[reference-dynamic-settings-reference]]
.Dynamic settings reference
ifndef::nonhtmloutput[]
[options="header"]
|===
|Name|Description
|<<config_causal_clustering.cluster_allow_reads_on_leader,causal_clustering.cluster_allow_reads_on_leader>>|Configure if the `dbms.routing.getRoutingTable()` procedure should include the leader as read endpoint or return only read replicas/followers.
|<<config_causal_clustering.connect_randomly_to_server_group,causal_clustering.connect_randomly_to_server_group>>|Comma separated list of groups to be used by the connect-randomly-to-server-group selection strategy.
|<<config_causal_clustering.server_groups,causal_clustering.server_groups>>|A list of group names for the server used when configuring load balancing and replication policies.
|<<config_dbms.allow_single_automatic_upgrade,dbms.allow_single_automatic_upgrade>>|Whether to allow a system graph upgrade to happen automatically in single instance mode (dbms.mode=SINGLE).
|<<config_dbms.allow_upgrade,dbms.allow_upgrade>>|Whether to allow a store upgrade in case the current version of the database starts against an older version of the store.
|<<config_dbms.backup.incremental.strategy,dbms.backup.incremental.strategy>>|Strategy for incremental backup.
|<<config_dbms.checkpoint.iops.limit,dbms.checkpoint.iops.limit>>|Limit the number of IOs the background checkpoint process will consume per second.
|<<config_dbms.databases.default_to_read_only,dbms.databases.default_to_read_only>>|Whether or not any database on this instance are read_only by default.
|<<config_dbms.databases.read_only,dbms.databases.read_only>>|List of databases for which to prevent write queries.
|<<config_dbms.databases.writable,dbms.databases.writable>>|List of databases for which to allow write queries.
|<<config_dbms.lock.acquisition.timeout,dbms.lock.acquisition.timeout>>|The maximum time interval within which lock should be acquired.
|<<config_dbms.logs.debug.level,dbms.logs.debug.level>>|Debug log level threshold.
|<<config_dbms.logs.query.allocation_logging_enabled,dbms.logs.query.allocation_logging_enabled>>|Log allocated bytes for the executed queries being logged.
|<<config_dbms.logs.query.early_raw_logging_enabled,dbms.logs.query.early_raw_logging_enabled>>|Log query text and parameters without obfuscating passwords.
|<<config_dbms.logs.query.enabled,dbms.logs.query.enabled>>|Log executed queries.
|<<config_dbms.logs.query.max_parameter_length,dbms.logs.query.max_parameter_length>>|Sets a maximum character length use for each parameter in the log.
|<<config_dbms.logs.query.obfuscate_literals,dbms.logs.query.obfuscate_literals>>|Obfuscates all literals of the query before writing to the log.
|<<config_dbms.logs.query.page_logging_enabled,dbms.logs.query.page_logging_enabled>>|Log page hits and page faults for the executed queries being logged.
|<<config_dbms.logs.query.parameter_full_entities,dbms.logs.query.parameter_full_entities>>|Log complete parameter entities including id, labels or relationship type, and properties.
|<<config_dbms.logs.query.parameter_logging_enabled,dbms.logs.query.parameter_logging_enabled>>|Log parameters for the executed queries being logged.
|<<config_dbms.logs.query.plan_description_enabled,dbms.logs.query.plan_description_enabled>>|Log query plan description table, useful for debugging purposes.
|<<config_dbms.logs.query.rotation.keep_number,dbms.logs.query.rotation.keep_number>>|Maximum number of history files for the query log.
|<<config_dbms.logs.query.rotation.size,dbms.logs.query.rotation.size>>|The file size in bytes at which the query log will auto-rotate.
|<<config_dbms.logs.query.runtime_logging_enabled,dbms.logs.query.runtime_logging_enabled>>|Logs which runtime that was used to run the query.
|<<config_dbms.logs.query.threshold,dbms.logs.query.threshold>>|If the execution of query takes more time than this threshold, the query is logged once completed - provided query logging is set to INFO.
|<<config_dbms.logs.query.time_logging_enabled,dbms.logs.query.time_logging_enabled>>|Log detailed time information for the executed queries being logged.
|<<config_dbms.logs.query.transaction.enabled,dbms.logs.query.transaction.enabled>>|Log the start and end of a transaction.
|<<config_dbms.logs.query.transaction.threshold,dbms.logs.query.transaction.threshold>>|If the transaction is open for more time than this threshold, the transaction is logged once completed - provided transaction logging (dbms.logs.query.transaction.enabled) is set to `INFO`.
|<<config_dbms.logs.query.transaction_id.enabled,dbms.logs.query.transaction_id.enabled>>|Log transaction ID for the executed queries.
|<<config_dbms.memory.pagecache.flush.buffer.enabled,dbms.memory.pagecache.flush.buffer.enabled>>|Page cache can be configured to use a temporal buffer for flushing purposes.
|<<config_dbms.memory.pagecache.flush.buffer.size_in_pages,dbms.memory.pagecache.flush.buffer.size_in_pages>>|Page cache can be configured to use a temporal buffer for flushing purposes.
|<<config_dbms.memory.transaction.database_max_size,dbms.memory.transaction.database_max_size>>|Limit the amount of memory that all transactions in one database can consume, in bytes (or kilobytes with the 'k' suffix, megabytes with 'm' and gigabytes with 'g').
|<<config_dbms.memory.transaction.global_max_size,dbms.memory.transaction.global_max_size>>|Limit the amount of memory that all of the running transactions can consume, in bytes (or kilobytes with the 'k' suffix, megabytes with 'm' and gigabytes with 'g').
|<<config_dbms.memory.transaction.max_size,dbms.memory.transaction.max_size>>|Limit the amount of memory that a single transaction can consume, in bytes (or kilobytes with the 'k' suffix, megabytes with 'm' and gigabytes with 'g').
|<<config_dbms.routing.client_side.enforce_for_domains,dbms.routing.client_side.enforce_for_domains>>|Always use client side routing (regardless of the default router) for neo4j:// protocol connections to these domains.
|<<config_dbms.security.ldap.authentication.attribute,dbms.security.ldap.authentication.attribute>>|The attribute to use when looking up users.
Using this setting requires `dbms.security.ldap.authentication.search_for_attribute` to be true and thus `dbms.security.ldap.authorization.system_username` and `dbms.security.ldap.authorization.system_password` to be configured.
|<<config_dbms.security.ldap.authentication.user_dn_template,dbms.security.ldap.authentication.user_dn_template>>|LDAP user DN template.
|<<config_dbms.security.ldap.authorization.access_permitted_group,dbms.security.ldap.authorization.access_permitted_group>>|The LDAP group to which a user must belong to get any access to the system.Set this to restrict access to a subset of LDAP users belonging to a particular group.
|<<config_dbms.security.ldap.authorization.group_membership_attributes,dbms.security.ldap.authorization.group_membership_attributes>>|A list of attribute names on a user object that contains groups to be used for mapping to roles when LDAP authorization is enabled.
|<<config_dbms.security.ldap.authorization.group_to_role_mapping,dbms.security.ldap.authorization.group_to_role_mapping>>|An authorization mapping from LDAP group names to Neo4j role names.
|<<config_dbms.security.ldap.authorization.user_search_base,dbms.security.ldap.authorization.user_search_base>>|The name of the base object or named context to search for user objects when LDAP authorization is enabled.
|<<config_dbms.security.ldap.authorization.user_search_filter,dbms.security.ldap.authorization.user_search_filter>>|The LDAP search filter to search for a user principal when LDAP authorization is enabled.
|<<config_dbms.track_query_allocation,dbms.track_query_allocation>>|Enables or disables tracking of how many bytes are allocated by the execution of a query.
|<<config_dbms.track_query_cpu_time,dbms.track_query_cpu_time>>|Enables or disables tracking of how much time a query spends actively executing on the CPU.
|<<config_dbms.transaction.bookmark_ready_timeout,dbms.transaction.bookmark_ready_timeout>>|The maximum amount of time to wait for the database state represented by the bookmark.
|<<config_dbms.transaction.concurrent.maximum,dbms.transaction.concurrent.maximum>>|The maximum number of concurrently running transactions.
|<<config_dbms.transaction.sampling.percentage,dbms.transaction.sampling.percentage>>|Transaction sampling percentage.
|<<config_dbms.transaction.timeout,dbms.transaction.timeout>>|The maximum time interval of a transaction within which it should be completed.
|<<config_dbms.transaction.tracing.level,dbms.transaction.tracing.level>>|Transaction creation tracing level.
|<<config_dbms.tx_log.preallocate,dbms.tx_log.preallocate>>|Specify if Neo4j should try to preallocate logical log file in advance.
|<<config_dbms.tx_log.rotation.retention_policy,dbms.tx_log.rotation.retention_policy>>|Tell Neo4j how long logical transaction logs should be kept to backup the database.For example, "10 days" will prune logical logs that only contain transactions older than 10 days.Alternatively, "100k txs" will keep the 100k latest transactions from each database and prune any older transactions.
|<<config_dbms.tx_log.rotation.size,dbms.tx_log.rotation.size>>|Specifies at which file size the logical log will auto-rotate.
|<<config_dbms.upgrade_max_processors,dbms.upgrade_max_processors>>|Max number of processors used when upgrading the store.
|<<config_fabric.routing.servers,fabric.routing.servers>>|A comma-separated list of Fabric instances that form a routing group.
|===
endif::nonhtmloutput[]

ifdef::nonhtmloutput[]
* <<config_causal_clustering.cluster_allow_reads_on_leader,causal_clustering.cluster_allow_reads_on_leader>>: Configure if the `dbms.routing.getRoutingTable()` procedure should include the leader as read endpoint or return only read replicas/followers.
* <<config_causal_clustering.connect_randomly_to_server_group,causal_clustering.connect_randomly_to_server_group>>: Comma separated list of groups to be used by the connect-randomly-to-server-group selection strategy.
* <<config_causal_clustering.server_groups,causal_clustering.server_groups>>: A list of group names for the server used when configuring load balancing and replication policies.
* <<config_dbms.allow_single_automatic_upgrade,dbms.allow_single_automatic_upgrade>>: Whether to allow a system graph upgrade to happen automatically in single instance mode (dbms.mode=SINGLE).
* <<config_dbms.allow_upgrade,dbms.allow_upgrade>>: Whether to allow a store upgrade in case the current version of the database starts against an older version of the store.
* <<config_dbms.backup.incremental.strategy,dbms.backup.incremental.strategy>>: Strategy for incremental backup.
* <<config_dbms.checkpoint.iops.limit,dbms.checkpoint.iops.limit>>: Limit the number of IOs the background checkpoint process will consume per second.
* <<config_dbms.databases.default_to_read_only,dbms.databases.default_to_read_only>>: Whether or not any database on this instance are read_only by default.
* <<config_dbms.databases.read_only,dbms.databases.read_only>>: List of databases for which to prevent write queries.
* <<config_dbms.databases.writable,dbms.databases.writable>>: List of databases for which to allow write queries.
* <<config_dbms.lock.acquisition.timeout,dbms.lock.acquisition.timeout>>: The maximum time interval within which lock should be acquired.
* <<config_dbms.logs.debug.level,dbms.logs.debug.level>>: Debug log level threshold.
* <<config_dbms.logs.query.allocation_logging_enabled,dbms.logs.query.allocation_logging_enabled>>: Log allocated bytes for the executed queries being logged.
* <<config_dbms.logs.query.early_raw_logging_enabled,dbms.logs.query.early_raw_logging_enabled>>: Log query text and parameters without obfuscating passwords.
* <<config_dbms.logs.query.enabled,dbms.logs.query.enabled>>: Log executed queries.
* <<config_dbms.logs.query.max_parameter_length,dbms.logs.query.max_parameter_length>>: Sets a maximum character length use for each parameter in the log.
* <<config_dbms.logs.query.obfuscate_literals,dbms.logs.query.obfuscate_literals>>: Obfuscates all literals of the query before writing to the log.
* <<config_dbms.logs.query.page_logging_enabled,dbms.logs.query.page_logging_enabled>>: Log page hits and page faults for the executed queries being logged.
* <<config_dbms.logs.query.parameter_full_entities,dbms.logs.query.parameter_full_entities>>: Log complete parameter entities including id, labels or relationship type, and properties.
* <<config_dbms.logs.query.parameter_logging_enabled,dbms.logs.query.parameter_logging_enabled>>: Log parameters for the executed queries being logged.
* <<config_dbms.logs.query.plan_description_enabled,dbms.logs.query.plan_description_enabled>>: Log query plan description table, useful for debugging purposes.
* <<config_dbms.logs.query.rotation.keep_number,dbms.logs.query.rotation.keep_number>>: Maximum number of history files for the query log.
* <<config_dbms.logs.query.rotation.size,dbms.logs.query.rotation.size>>: The file size in bytes at which the query log will auto-rotate.
* <<config_dbms.logs.query.runtime_logging_enabled,dbms.logs.query.runtime_logging_enabled>>: Logs which runtime that was used to run the query.
* <<config_dbms.logs.query.threshold,dbms.logs.query.threshold>>: If the execution of query takes more time than this threshold, the query is logged once completed - provided query logging is set to INFO.
* <<config_dbms.logs.query.time_logging_enabled,dbms.logs.query.time_logging_enabled>>: Log detailed time information for the executed queries being logged.
* <<config_dbms.logs.query.transaction.enabled,dbms.logs.query.transaction.enabled>>: Log the start and end of a transaction.
* <<config_dbms.logs.query.transaction.threshold,dbms.logs.query.transaction.threshold>>: If the transaction is open for more time than this threshold, the transaction is logged once completed - provided transaction logging (dbms.logs.query.transaction.enabled) is set to `INFO`.
* <<config_dbms.logs.query.transaction_id.enabled,dbms.logs.query.transaction_id.enabled>>: Log transaction ID for the executed queries.
* <<config_dbms.memory.pagecache.flush.buffer.enabled,dbms.memory.pagecache.flush.buffer.enabled>>: Page cache can be configured to use a temporal buffer for flushing purposes.
* <<config_dbms.memory.pagecache.flush.buffer.size_in_pages,dbms.memory.pagecache.flush.buffer.size_in_pages>>: Page cache can be configured to use a temporal buffer for flushing purposes.
* <<config_dbms.memory.transaction.database_max_size,dbms.memory.transaction.database_max_size>>: Limit the amount of memory that all transactions in one database can consume, in bytes (or kilobytes with the 'k' suffix, megabytes with 'm' and gigabytes with 'g').
* <<config_dbms.memory.transaction.global_max_size,dbms.memory.transaction.global_max_size>>: Limit the amount of memory that all of the running transactions can consume, in bytes (or kilobytes with the 'k' suffix, megabytes with 'm' and gigabytes with 'g').
* <<config_dbms.memory.transaction.max_size,dbms.memory.transaction.max_size>>: Limit the amount of memory that a single transaction can consume, in bytes (or kilobytes with the 'k' suffix, megabytes with 'm' and gigabytes with 'g').
* <<config_dbms.routing.client_side.enforce_for_domains,dbms.routing.client_side.enforce_for_domains>>: Always use client side routing (regardless of the default router) for neo4j:// protocol connections to these domains.
* <<config_dbms.security.ldap.authentication.attribute,dbms.security.ldap.authentication.attribute>>: The attribute to use when looking up users.
Using this setting requires `dbms.security.ldap.authentication.search_for_attribute` to be true and thus `dbms.security.ldap.authorization.system_username` and `dbms.security.ldap.authorization.system_password` to be configured.
* <<config_dbms.security.ldap.authentication.user_dn_template,dbms.security.ldap.authentication.user_dn_template>>: LDAP user DN template.
* <<config_dbms.security.ldap.authorization.access_permitted_group,dbms.security.ldap.authorization.access_permitted_group>>: The LDAP group to which a user must belong to get any access to the system.Set this to restrict access to a subset of LDAP users belonging to a particular group.
* <<config_dbms.security.ldap.authorization.group_membership_attributes,dbms.security.ldap.authorization.group_membership_attributes>>: A list of attribute names on a user object that contains groups to be used for mapping to roles when LDAP authorization is enabled.
* <<config_dbms.security.ldap.authorization.group_to_role_mapping,dbms.security.ldap.authorization.group_to_role_mapping>>: An authorization mapping from LDAP group names to Neo4j role names.
* <<config_dbms.security.ldap.authorization.user_search_base,dbms.security.ldap.authorization.user_search_base>>: The name of the base object or named context to search for user objects when LDAP authorization is enabled.
* <<config_dbms.security.ldap.authorization.user_search_filter,dbms.security.ldap.authorization.user_search_filter>>: The LDAP search filter to search for a user principal when LDAP authorization is enabled.
* <<config_dbms.track_query_allocation,dbms.track_query_allocation>>: Enables or disables tracking of how many bytes are allocated by the execution of a query.
* <<config_dbms.track_query_cpu_time,dbms.track_query_cpu_time>>: Enables or disables tracking of how much time a query spends actively executing on the CPU.
* <<config_dbms.transaction.bookmark_ready_timeout,dbms.transaction.bookmark_ready_timeout>>: The maximum amount of time to wait for the database state represented by the bookmark.
* <<config_dbms.transaction.concurrent.maximum,dbms.transaction.concurrent.maximum>>: The maximum number of concurrently running transactions.
* <<config_dbms.transaction.sampling.percentage,dbms.transaction.sampling.percentage>>: Transaction sampling percentage.
* <<config_dbms.transaction.timeout,dbms.transaction.timeout>>: The maximum time interval of a transaction within which it should be completed.
* <<config_dbms.transaction.tracing.level,dbms.transaction.tracing.level>>: Transaction creation tracing level.
* <<config_dbms.tx_log.preallocate,dbms.tx_log.preallocate>>: Specify if Neo4j should try to preallocate logical log file in advance.
* <<config_dbms.tx_log.rotation.retention_policy,dbms.tx_log.rotation.retention_policy>>: Tell Neo4j how long logical transaction logs should be kept to backup the database.For example, "10 days" will prune logical logs that only contain transactions older than 10 days.Alternatively, "100k txs" will keep the 100k latest transactions from each database and prune any older transactions.
* <<config_dbms.tx_log.rotation.size,dbms.tx_log.rotation.size>>: Specifies at which file size the logical log will auto-rotate.
* <<config_dbms.upgrade_max_processors,dbms.upgrade_max_processors>>: Max number of processors used when upgrading the store.
* <<config_fabric.routing.servers,fabric.routing.servers>>: A comma-separated list of Fabric instances that form a routing group.
endif::nonhtmloutput[]


// end::reference-dynamic-settings-reference[]

[[config_causal_clustering.cluster_allow_reads_on_leader]]
.causal_clustering.cluster_allow_reads_on_leader
[cols="<1s,<4"]
|===
|Description
a|Configure if the `dbms.routing.getRoutingTable()` procedure should include the leader as read endpoint or return only read replicas/followers. Note: leader is returned as read endpoint if no other member is present all.
|Valid values
a|causal_clustering.cluster_allow_reads_on_leader, a boolean
|Dynamic a|true
|Default value
m|false
|===

[[config_causal_clustering.connect_randomly_to_server_group]]
.causal_clustering.connect_randomly_to_server_group
[cols="<1s,<4"]
|===
|Description
a|Comma separated list of groups to be used by the connect-randomly-to-server-group selection strategy. The connect-randomly-to-server-group strategy is used if the list of strategies (`causal_clustering.upstream_selection_strategy`) includes the value `connect-randomly-to-server-group`.
|Valid values
a|causal_clustering.connect_randomly_to_server_group, a ',' separated list with elements of type 'a string identifying a Server Group'.
|Dynamic a|true
|Default value
m|
|===

[[config_causal_clustering.server_groups]]
.causal_clustering.server_groups
[cols="<1s,<4"]
|===
|Description
a|A list of group names for the server used when configuring load balancing and replication policies.
|Valid values
a|causal_clustering.server_groups, a ',' separated list with elements of type 'a string identifying a Server Group'.
|Dynamic a|true
|Default value
m|
|===

[[config_dbms.allow_single_automatic_upgrade]]
.dbms.allow_single_automatic_upgrade
[cols="<1s,<4"]
|===
|Description
a|Whether to allow a system graph upgrade to happen automatically in single instance mode (dbms.mode=SINGLE). Default is true. In clustering environments no automatic upgrade will happen (dbms.mode=CORE or dbms.mode=READ_REPLICA). If set to false, or when in a clustering environment, it is necessary to call the procedure `dbms.upgrade()` to complete the upgrade.
|Valid values
a|dbms.allow_single_automatic_upgrade, a boolean
|Dynamic a|true
|Default value
m|true
|===

[[config_dbms.allow_upgrade]]
.dbms.allow_upgrade
[cols="<1s,<4"]
|===
|Description
a|Whether to allow a store upgrade in case the current version of the database starts against an older version of the store.
|Valid values
a|dbms.allow_upgrade, a boolean
|Dynamic a|true
|Default value
m|false
|===

[[config_dbms.backup.incremental.strategy]]
.dbms.backup.incremental.strategy
[cols="<1s,<4"]
|===
|Description
a|Strategy for incremental backup. START_TIME means that this server will send transactions until the time of when the backup started has been reached. UNBOUNDED will keep sending until all committed transactions have been sent, even if they where committed after the backup job started.
|Valid values
a|dbms.backup.incremental.strategy, one of [UNBOUNDED, START_TIME]
|Dynamic a|true
|Default value
m|UNBOUNDED
|===

[[config_dbms.checkpoint.iops.limit]]
.dbms.checkpoint.iops.limit
[cols="<1s,<4"]
|===
|Description
a|Limit the number of IOs the background checkpoint process will consume per second. This setting is advisory, is ignored in Neo4j Community Edition, and is followed to best effort in Enterprise Edition. An IO is in this case a 8 KiB (mostly sequential) write. Limiting the write IO in this way will leave more bandwidth in the IO subsystem to service random-read IOs, which is important for the response time of queries when the database cannot fit entirely in memory. The only drawback of this setting is that longer checkpoint times may lead to slightly longer recovery times in case of a database or system crash. A lower number means lower IO pressure, and consequently longer checkpoint times. Set this to -1 to disable the IOPS limit and remove the limitation entirely; this will let the checkpointer flush data as fast as the hardware will go. Removing the setting, or commenting it out, will set the default value of 600.
|Valid values
a|dbms.checkpoint.iops.limit, an integer
|Dynamic a|true
|Default value
m|600
|===

[[config_dbms.databases.default_to_read_only]]
.dbms.databases.default_to_read_only
[cols="<1s,<4"]
|===
|Description
a|Whether or not any database on this instance are read_only by default. If false, individual databases may be marked as read_only using dbms.database.read_only. If true, individual databases may be marked as writable using <<config_dbms.databases.writable,dbms.databases.writable>>.
|Valid values
a|dbms.databases.default_to_read_only, a boolean
|Dynamic a|true
|Default value
m|false
|===

[[config_dbms.databases.read_only]]
.dbms.databases.read_only
[cols="<1s,<4"]
|===
|Description
a|List of databases for which to prevent write queries. Databases not included in this list maybe read_only anyway depending upon the value of <<config_dbms.databases.default_to_read_only,dbms.databases.default_to_read_only>>.
|Valid values
a|dbms.databases.read_only, a ',' separated set with elements of type 'A valid database name. Containing only alphabetic characters, numbers, dots and dashes, with a length between 3 and 63 characters. It should be starting with an alphabetic character but not with the name 'system'.'. which Value 'system' can't be included in read only databases collection!
|Dynamic a|true
|Default value
m|
|===

[[config_dbms.databases.writable]]
.dbms.databases.writable
[cols="<1s,<4"]
|===
|Description
a|List of databases for which to allow write queries. Databases not included in this list will allow write queries anyway, unless <<config_dbms.databases.default_to_read_only,dbms.databases.default_to_read_only>> is set to true.
|Valid values
a|dbms.databases.writable, a ',' separated set with elements of type 'A valid database name. Containing only alphabetic characters, numbers, dots and dashes, with a length between 3 and 63 characters. It should be starting with an alphabetic character but not with the name 'system'.'.
|Dynamic a|true
|Default value
m|
|===

[[config_dbms.lock.acquisition.timeout]]
.dbms.lock.acquisition.timeout
[cols="<1s,<4"]
|===
|Description
a|The maximum time interval within which lock should be acquired. Zero (default) means timeout is disabled.
|Valid values
a|dbms.lock.acquisition.timeout, a duration (Valid units are: 'ns', 'μs', 'ms', 's', 'm', 'h' and 'd'; default unit is 's')
|Dynamic a|true
|Default value
m|0s
|===

[[config_dbms.logs.debug.level]]
.dbms.logs.debug.level
[cols="<1s,<4"]
|===
|Description
a|Debug log level threshold.
|Valid values
a|dbms.logs.debug.level, one of [DEBUG, INFO, WARN, ERROR, NONE]
|Dynamic a|true
|Default value
m|INFO
|===

[[config_dbms.logs.query.allocation_logging_enabled]]
.dbms.logs.query.allocation_logging_enabled
[cols="<1s,<4"]
|===
|Description
a|Log allocated bytes for the executed queries being logged. The logged number is cumulative over the duration of the query, i.e. for memory intense or long-running queries the value may be larger than the current memory allocation. Requires `<<config_dbms.track_query_allocation,dbms.track_query_allocation>>=true`
|Valid values
a|dbms.logs.query.allocation_logging_enabled, a boolean
|Dynamic a|true
|Default value
m|true
|===

[[config_dbms.logs.query.early_raw_logging_enabled]]
.dbms.logs.query.early_raw_logging_enabled
[cols="<1s,<4"]
|===
|Description
a|Log query text and parameters without obfuscating passwords. This allows queries to be logged earlier before parsing starts.
|Valid values
a|dbms.logs.query.early_raw_logging_enabled, a boolean
|Dynamic a|true
|Default value
m|false
|===

[[config_dbms.logs.query.enabled]]
.dbms.logs.query.enabled
[cols="<1s,<4"]
|===
|Description
a|Log executed queries. Valid values are 'OFF', 'INFO', or 'VERBOSE'.
OFF:  no logging.
INFO: log queries at the end of execution, that take longer than the configured threshold, <<config_dbms.logs.query.threshold,dbms.logs.query.threshold>>.
VERBOSE: log queries at the start and end of execution, regardless of <<config_dbms.logs.query.threshold,dbms.logs.query.threshold>>.
Log entries are written to the query log (dbms.logs.query.path).
This feature is available in the Neo4j Enterprise Edition.
|Valid values
a|dbms.logs.query.enabled, one of [OFF, INFO, VERBOSE]
|Dynamic a|true
|Default value
m|VERBOSE
|===

[[config_dbms.logs.query.max_parameter_length]]
.dbms.logs.query.max_parameter_length
[cols="<1s,<4"]
|===
|Description
a|Sets a maximum character length use for each parameter in the log. This only takes effect if `<<config_dbms.logs.query.parameter_logging_enabled,dbms.logs.query.parameter_logging_enabled>> = true`.
|Valid values
a|dbms.logs.query.max_parameter_length, an integer
|Dynamic a|true
|Default value
m|2147483647
|===

[[config_dbms.logs.query.obfuscate_literals]]
.dbms.logs.query.obfuscate_literals
[cols="<1s,<4"]
|===
|Description
a|Obfuscates all literals of the query before writing to the log. Note that node labels, relationship types and map property keys are still shown. Changing the setting will not affect queries that are cached. So, if you want the switch to have immediate effect, you must also call `CALL db.clearQueryCaches()`.
|Valid values
a|dbms.logs.query.obfuscate_literals, a boolean
|Dynamic a|true
|Default value
m|false
|===

[[config_dbms.logs.query.page_logging_enabled]]
.dbms.logs.query.page_logging_enabled
[cols="<1s,<4"]
|===
|Description
a|Log page hits and page faults for the executed queries being logged.
|Valid values
a|dbms.logs.query.page_logging_enabled, a boolean
|Dynamic a|true
|Default value
m|false
|===

[[config_dbms.logs.query.parameter_full_entities]]
.dbms.logs.query.parameter_full_entities
[cols="<1s,<4"]
|===
|Description
a|Log complete parameter entities including id, labels or relationship type, and properties. If false, only the entity id will be logged. This only takes effect if `<<config_dbms.logs.query.parameter_logging_enabled,dbms.logs.query.parameter_logging_enabled>> = true`.
|Valid values
a|dbms.logs.query.parameter_full_entities, a boolean
|Dynamic a|true
|Default value
m|false
|===

[[config_dbms.logs.query.parameter_logging_enabled]]
.dbms.logs.query.parameter_logging_enabled
[cols="<1s,<4"]
|===
|Description
a|Log parameters for the executed queries being logged.
|Valid values
a|dbms.logs.query.parameter_logging_enabled, a boolean
|Dynamic a|true
|Default value
m|true
|===

[[config_dbms.logs.query.plan_description_enabled]]
.dbms.logs.query.plan_description_enabled
[cols="<1s,<4"]
|===
|Description
a|Log query plan description table, useful for debugging purposes.
|Valid values
a|dbms.logs.query.plan_description_enabled, a boolean
|Dynamic a|true
|Default value
m|false
|===

[[config_dbms.logs.query.rotation.keep_number]]
.dbms.logs.query.rotation.keep_number
[cols="<1s,<4"]
|===
|Description
a|Maximum number of history files for the query log.
|Valid values
a|dbms.logs.query.rotation.keep_number, an integer which is minimum `1`
|Dynamic a|true
|Default value
m|7
|===

[[config_dbms.logs.query.rotation.size]]
.dbms.logs.query.rotation.size
[cols="<1s,<4"]
|===
|Description
a|The file size in bytes at which the query log will auto-rotate. If set to zero then no rotation will occur. Accepts a binary suffix `k`, `m` or `g`.
|Valid values
a|dbms.logs.query.rotation.size, a byte size (valid multipliers are `B`, `KiB`, `KB`, `K`, `kB`, `kb`, `k`, `MiB`, `MB`, `M`, `mB`, `mb`, `m`, `GiB`, `GB`, `G`, `gB`, `gb`, `g`, `TiB`, `TB`, `PiB`, `PB`, `EiB`, `EB`) which is in the range `0B` to `8388608.00TiB`
|Dynamic a|true
|Default value
m|20.00MiB
|===

[[config_dbms.logs.query.runtime_logging_enabled]]
.dbms.logs.query.runtime_logging_enabled
[cols="<1s,<4"]
|===
|Description
a|Logs which runtime that was used to run the query.
|Valid values
a|dbms.logs.query.runtime_logging_enabled, a boolean
|Dynamic a|true
|Default value
m|true
|===

[[config_dbms.logs.query.threshold]]
.dbms.logs.query.threshold
[cols="<1s,<4"]
|===
|Description
a|If the execution of query takes more time than this threshold, the query is logged once completed - provided query logging is set to INFO. Defaults to 0 seconds, that is all queries are logged.
|Valid values
a|dbms.logs.query.threshold, a duration (Valid units are: 'ns', 'μs', 'ms', 's', 'm', 'h' and 'd'; default unit is 's')
|Dynamic a|true
|Default value
m|0s
|===

[[config_dbms.logs.query.time_logging_enabled]]
.dbms.logs.query.time_logging_enabled
[cols="<1s,<4"]
|===
|Description
a|Log detailed time information for the executed queries being logged. Requires `<<config_dbms.track_query_cpu_time,dbms.track_query_cpu_time>>=true`
|Valid values
a|dbms.logs.query.time_logging_enabled, a boolean
|Dynamic a|true
|Default value
m|false
|===

[[config_dbms.logs.query.transaction.enabled]]
.dbms.logs.query.transaction.enabled
[cols="<1s,<4"]
|===
|Description
a|Log the start and end of a transaction. Valid values are 'OFF', 'INFO', or 'VERBOSE'.
OFF:  no logging.
INFO: log start and end of transactions that take longer than the configured threshold, <<config_dbms.logs.query.transaction.threshold,dbms.logs.query.transaction.threshold>>.
VERBOSE: log start and end of all transactions.
Log entries are written to the query log (dbms.logs.query.path).
This feature is available in the Neo4j Enterprise Edition.
|Valid values
a|dbms.logs.query.transaction.enabled, one of [OFF, INFO, VERBOSE]
|Dynamic a|true
|Default value
m|OFF
|===

[[config_dbms.logs.query.transaction.threshold]]
.dbms.logs.query.transaction.threshold
[cols="<1s,<4"]
|===
|Description
a|If the transaction is open for more time than this threshold, the transaction is logged once completed - provided transaction logging (<<config_dbms.logs.query.transaction.enabled,dbms.logs.query.transaction.enabled>>) is set to `INFO`. Defaults to 0 seconds (all transactions are logged).
|Valid values
a|dbms.logs.query.transaction.threshold, a duration (Valid units are: 'ns', 'μs', 'ms', 's', 'm', 'h' and 'd'; default unit is 's')
|Dynamic a|true
|Default value
m|0s
|===

[[config_dbms.logs.query.transaction_id.enabled]]
.dbms.logs.query.transaction_id.enabled
[cols="<1s,<4"]
|===
|Description
a|Log transaction ID for the executed queries.
|Valid values
a|dbms.logs.query.transaction_id.enabled, a boolean
|Dynamic a|true
|Default value
m|false
|===

[[config_dbms.memory.pagecache.flush.buffer.enabled]]
.dbms.memory.pagecache.flush.buffer.enabled
[cols="<1s,<4"]
|===
|Description
a|Page cache can be configured to use a temporal buffer for flushing purposes. It is used to combine, if possible, sequence of several cache pages into one bigger buffer to minimize the number of individual IOPS performed and better utilization of available I/O resources, especially when those are restricted.
|Valid values
a|dbms.memory.pagecache.flush.buffer.enabled, a boolean
|Dynamic a|true
|Default value
m|false
|===

[[config_dbms.memory.pagecache.flush.buffer.size_in_pages]]
.dbms.memory.pagecache.flush.buffer.size_in_pages
[cols="<1s,<4"]
|===
|Description
a|Page cache can be configured to use a temporal buffer for flushing purposes. It is used to combine, if possible, sequence of several cache pages into one bigger buffer to minimize the number of individual IOPS performed and better utilization of available I/O resources, especially when those are restricted. Use this setting to configure individual file flush buffer size in pages (8KiB). To be able to utilize this buffer during page cache flushing, buffered flush should be enabled.
|Valid values
a|dbms.memory.pagecache.flush.buffer.size_in_pages, an integer which is in the range `1` to `512`
|Dynamic a|true
|Default value
m|128
|===

[[config_dbms.memory.transaction.database_max_size]]
.dbms.memory.transaction.database_max_size
[cols="<1s,<4"]
|===
|Description
a|Limit the amount of memory that all transactions in one database can consume, in bytes (or kilobytes with the 'k' suffix, megabytes with 'm' and gigabytes with 'g'). Zero means 'unlimited'.
|Valid values
a|dbms.memory.transaction.database_max_size, a byte size (valid multipliers are `B`, `KiB`, `KB`, `K`, `kB`, `kb`, `k`, `MiB`, `MB`, `M`, `mB`, `mb`, `m`, `GiB`, `GB`, `G`, `gB`, `gb`, `g`, `TiB`, `TB`, `PiB`, `PB`, `EiB`, `EB`) which is minimum `10.00MiB` or is `0B`
|Dynamic a|true
|Default value
m|0B
|===

[[config_dbms.memory.transaction.global_max_size]]
.dbms.memory.transaction.global_max_size
[cols="<1s,<4"]
|===
|Description
a|Limit the amount of memory that all of the running transactions can consume, in bytes (or kilobytes with the 'k' suffix, megabytes with 'm' and gigabytes with 'g'). Zero means 'unlimited'.
|Valid values
a|dbms.memory.transaction.global_max_size, a byte size (valid multipliers are `B`, `KiB`, `KB`, `K`, `kB`, `kb`, `k`, `MiB`, `MB`, `M`, `mB`, `mb`, `m`, `GiB`, `GB`, `G`, `gB`, `gb`, `g`, `TiB`, `TB`, `PiB`, `PB`, `EiB`, `EB`) which is minimum `10.00MiB` or is `0B`
|Dynamic a|true
|Default value
m|0B
|===

[[config_dbms.memory.transaction.max_size]]
.dbms.memory.transaction.max_size
[cols="<1s,<4"]
|===
|Description
a|Limit the amount of memory that a single transaction can consume, in bytes (or kilobytes with the 'k' suffix, megabytes with 'm' and gigabytes with 'g'). Zero means 'largest possible value'. When `dbms.mode=SINGLE` this is 'unlimited'. When `dbms.mode=CORE` or `dbms.mode=READ_REPLICA` this is '2G'.
|Valid values
a|dbms.memory.transaction.max_size, a byte size (valid multipliers are `B`, `KiB`, `KB`, `K`, `kB`, `kb`, `k`, `MiB`, `MB`, `M`, `mB`, `mb`, `m`, `GiB`, `GB`, `G`, `gB`, `gb`, `g`, `TiB`, `TB`, `PiB`, `PB`, `EiB`, `EB`) which is minimum `1.00MiB` or is `0B` and depends on dbms.mode. If dbms.mode is `CORE` or is `READ_REPLICA` then it is maximum `2.00GiB` otherwise it is unconstrained.
|Dynamic a|true
|Default value
m|0B
|===

[[config_dbms.routing.client_side.enforce_for_domains]]
.dbms.routing.client_side.enforce_for_domains
[cols="<1s,<4"]
|===
|Description
a|Always use client side routing (regardless of the default router) for neo4j:// protocol connections to these domains. A comma seperated list of domains. Wildcards (*) are supported.
|Valid values
a|dbms.routing.client_side.enforce_for_domains, a ',' separated set with elements of type 'a string'.
|Dynamic a|true
|Default value
m|
|===

[[config_dbms.security.ldap.authentication.attribute]]
.dbms.security.ldap.authentication.attribute
[cols="<1s,<4"]
|===
|Description
a|The attribute to use when looking up users.
Using this setting requires `dbms.security.ldap.authentication.search_for_attribute` to be true and thus `dbms.security.ldap.authorization.system_username` and `dbms.security.ldap.authorization.system_password` to be configured.
|Valid values
a|dbms.security.ldap.authentication.attribute, a string which matches the pattern `[A-Za-z0-9-]*` (has to be a valid LDAP attribute name, only containing letters [A-Za-z], digits [0-9] and hyphens [-].)
|Dynamic a|true
|Default value
m|samaccountname
|===

[[config_dbms.security.ldap.authentication.user_dn_template]]
.dbms.security.ldap.authentication.user_dn_template
[cols="<1s,<4"]
|===
|Description
a|LDAP user DN template. An LDAP object is referenced by its distinguished name (DN), and a user DN is an LDAP fully-qualified unique user identifier. This setting is used to generate an LDAP DN that conforms with the LDAP directory's schema from the user principal that is submitted with the authentication token when logging in. The special token {0} is a placeholder where the user principal will be substituted into the DN string.
|Valid values
a|dbms.security.ldap.authentication.user_dn_template, a string which Must be a string containing '{0}' to understand where to insert the runtime authentication principal.
|Dynamic a|true
|Default value
m|uid={0},ou=users,dc=example,dc=com
|===

[[config_dbms.security.ldap.authorization.access_permitted_group]]
.dbms.security.ldap.authorization.access_permitted_group
[cols="<1s,<4"]
|===
|Description
a|The LDAP group to which a user must belong to get any access to the system.Set this to restrict access to a subset of LDAP users belonging to a particular group. If this is not set, any user to successfully authenticate via LDAP will have access to the PUBLIC role and any other roles assigned to them via <<config_dbms.security.ldap.authorization.group_to_role_mapping,dbms.security.ldap.authorization.group_to_role_mapping>>.
|Valid values
a|dbms.security.ldap.authorization.access_permitted_group, a string
|Dynamic a|true
|Default value
m|
|===

[[config_dbms.security.ldap.authorization.group_membership_attributes]]
.dbms.security.ldap.authorization.group_membership_attributes
[cols="<1s,<4"]
|===
|Description
a|A list of attribute names on a user object that contains groups to be used for mapping to roles when LDAP authorization is enabled.
|Valid values
a|dbms.security.ldap.authorization.group_membership_attributes, a ',' separated list with elements of type 'a string'. which Can not be empty
|Dynamic a|true
|Default value
m|memberOf
|===

[[config_dbms.security.ldap.authorization.group_to_role_mapping]]
.dbms.security.ldap.authorization.group_to_role_mapping
[cols="<1s,<4"]
|===
|Description
a|An authorization mapping from LDAP group names to Neo4j role names. The map should be formatted as a semicolon separated list of key-value pairs, where the key is the LDAP group name and the value is a comma separated list of corresponding role names. For example: group1=role1;group2=role2;group3=role3,role4,role5
You could also use whitespaces and quotes around group names to make this mapping more readable, for example: 
----
dbms.security.ldap.authorization.group_to_role_mapping=\
         "cn=Neo4j Read Only,cn=users,dc=example,dc=com"      = reader;    \
         "cn=Neo4j Read-Write,cn=users,dc=example,dc=com"     = publisher; \
         "cn=Neo4j Schema Manager,cn=users,dc=example,dc=com" = architect; \
         "cn=Neo4j Administrator,cn=users,dc=example,dc=com"  = admin
----
|Valid values
a|dbms.security.ldap.authorization.group_to_role_mapping, a string which must be semicolon separated list of key-value pairs or empty
|Dynamic a|true
|Default value
m|
|===

[[config_dbms.security.ldap.authorization.user_search_base]]
.dbms.security.ldap.authorization.user_search_base
[cols="<1s,<4"]
|===
|Description
a|The name of the base object or named context to search for user objects when LDAP authorization is enabled. A common case is that this matches the last part of `<<config_dbms.security.ldap.authentication.user_dn_template,dbms.security.ldap.authentication.user_dn_template>>`.
|Valid values
a|dbms.security.ldap.authorization.user_search_base, a string which Can not be empty
|Dynamic a|true
|Default value
m|ou=users,dc=example,dc=com
|===

[[config_dbms.security.ldap.authorization.user_search_filter]]
.dbms.security.ldap.authorization.user_search_filter
[cols="<1s,<4"]
|===
|Description
a|The LDAP search filter to search for a user principal when LDAP authorization is enabled. The filter should contain the placeholder token {0} which will be substituted for the user principal.
|Valid values
a|dbms.security.ldap.authorization.user_search_filter, a string
|Dynamic a|true
|Default value
m|(&(objectClass=*)(uid={0}))
|===

[[config_dbms.track_query_allocation]]
.dbms.track_query_allocation
[cols="<1s,<4"]
|===
|Description
a|Enables or disables tracking of how many bytes are allocated by the execution of a query. If enabled, calling `dbms.listQueries` will display the allocated bytes. This can also be logged in the query log by using `<<config_dbms.logs.query.allocation_logging_enabled,dbms.logs.query.allocation_logging_enabled>>`.
|Valid values
a|dbms.track_query_allocation, a boolean
|Dynamic a|true
|Default value
m|true
|===

[[config_dbms.track_query_cpu_time]]
.dbms.track_query_cpu_time
[cols="<1s,<4"]
|===
|Description
a|Enables or disables tracking of how much time a query spends actively executing on the CPU. Calling `dbms.listQueries` will display the time. This can also be logged in the query log by using `<<config_dbms.logs.query.time_logging_enabled,dbms.logs.query.time_logging_enabled>>`.
|Valid values
a|dbms.track_query_cpu_time, a boolean
|Dynamic a|true
|Default value
m|false
|===

[[config_dbms.transaction.bookmark_ready_timeout]]
.dbms.transaction.bookmark_ready_timeout
[cols="<1s,<4"]
|===
|Description
a|The maximum amount of time to wait for the database state represented by the bookmark.
|Valid values
a|dbms.transaction.bookmark_ready_timeout, a duration (Valid units are: 'ns', 'μs', 'ms', 's', 'm', 'h' and 'd'; default unit is 's') which is minimum `1s`
|Dynamic a|true
|Default value
m|30s
|===

[[config_dbms.transaction.concurrent.maximum]]
.dbms.transaction.concurrent.maximum
[cols="<1s,<4"]
|===
|Description
a|The maximum number of concurrently running transactions. If set to 0, limit is disabled.
|Valid values
a|dbms.transaction.concurrent.maximum, an integer
|Dynamic a|true
|Default value
m|1000
|===

[[config_dbms.transaction.sampling.percentage]]
.dbms.transaction.sampling.percentage
[cols="<1s,<4"]
|===
|Description
a|Transaction sampling percentage.
|Valid values
a|dbms.transaction.sampling.percentage, an integer which is in the range `1` to `100`
|Dynamic a|true
|Default value
m|5
|===

[[config_dbms.transaction.timeout]]
.dbms.transaction.timeout
[cols="<1s,<4"]
|===
|Description
a|The maximum time interval of a transaction within which it should be completed.
|Valid values
a|dbms.transaction.timeout, a duration (Valid units are: 'ns', 'μs', 'ms', 's', 'm', 'h' and 'd'; default unit is 's')
|Dynamic a|true
|Default value
m|0s
|===

[[config_dbms.transaction.tracing.level]]
.dbms.transaction.tracing.level
[cols="<1s,<4"]
|===
|Description
a|Transaction creation tracing level.
|Valid values
a|dbms.transaction.tracing.level, one of [DISABLED, SAMPLE, ALL]
|Dynamic a|true
|Default value
m|DISABLED
|===

[[config_dbms.tx_log.preallocate]]
.dbms.tx_log.preallocate
[cols="<1s,<4"]
|===
|Description
a|Specify if Neo4j should try to preallocate logical log file in advance.
|Valid values
a|dbms.tx_log.preallocate, a boolean
|Dynamic a|true
|Default value
m|true
|===

[[config_dbms.tx_log.rotation.retention_policy]]
.dbms.tx_log.rotation.retention_policy
[cols="<1s,<4"]
|===
|Description
a|Tell Neo4j how long logical transaction logs should be kept to backup the database.For example, "10 days" will prune logical logs that only contain transactions older than 10 days.Alternatively, "100k txs" will keep the 100k latest transactions from each database and prune any older transactions.
|Valid values
a|dbms.tx_log.rotation.retention_policy, a string which matches the pattern `^(true{vbar}keep_all{vbar}false{vbar}keep_none{vbar}(\d+[KkMmGg]?( (files{vbar}size{vbar}txs{vbar}entries{vbar}hours{vbar}days))))$` (Must be `true` or `keep_all`, `false` or `keep_none`, or of format `<number><optional unit> <type>`. Valid units are `K`, `M` and `G`. Valid types are `files`, `size`, `txs`, `entries`, `hours` and `days`. For example, `100M size` will limit logical log space on disk to 100MB per database,and `200K txs` will limit the number of transactions kept to 200 000 per database.)
|Dynamic a|true
|Default value
m|7 days
|===

[[config_dbms.tx_log.rotation.size]]
.dbms.tx_log.rotation.size
[cols="<1s,<4"]
|===
|Description
a|Specifies at which file size the logical log will auto-rotate. Minimum accepted value is 128 KiB.
|Valid values
a|dbms.tx_log.rotation.size, a byte size (valid multipliers are `B`, `KiB`, `KB`, `K`, `kB`, `kb`, `k`, `MiB`, `MB`, `M`, `mB`, `mb`, `m`, `GiB`, `GB`, `G`, `gB`, `gb`, `g`, `TiB`, `TB`, `PiB`, `PB`, `EiB`, `EB`) which is minimum `128.00KiB`
|Dynamic a|true
|Default value
m|250.00MiB
|===

[[config_dbms.upgrade_max_processors]]
.dbms.upgrade_max_processors
[cols="<1s,<4"]
|===
|Description
a|Max number of processors used when upgrading the store. Defaults to the number of processors available to the JVM. There is a certain amount of minimum threads needed so for that reason there is no lower bound for this value. For optimal performance this value shouldn't be greater than the number of available processors.
|Valid values
a|dbms.upgrade_max_processors, an integer which is minimum `0`
|Dynamic a|true
|Default value
m|0
|===

[[config_fabric.routing.servers]]
.fabric.routing.servers
[cols="<1s,<4"]
|===
|Description
a|A comma-separated list of Fabric instances that form a routing group. A driver will route transactions to available routing group members.
A Fabric instance is represented by its Bolt connector address.
|Valid values
a|fabric.routing.servers, a ',' separated list with elements of type 'a socket address'.
|Dynamic a|true
|===

