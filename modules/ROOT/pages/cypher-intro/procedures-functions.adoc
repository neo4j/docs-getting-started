= How to extend Cypher
:tags: cypher, queries, extend-cypher, procedures, functions, custom-development
:description: This guide explains how to use, create and deploy user defined procedures and functions, the extension mechanism of Cypher, Neo4j's query language. It also covers existing, widely used procedure libraries
:page-ad-overline-link: https://graphacademy.neo4j.com/categories/cypher/
:page-ad-overline: Neo4j GraphAcademy
:page-ad-title: Cypher Courses
:page-ad-description: Learn Cypher in this free, hands-on courses
:page-ad-link: https://graphacademy.neo4j.com/categories/cypher/
:page-ad-underline-role: button
:page-ad-underline: Learn more

// To rename this section: How to extend Cypher (or Neo4j). See https://neo4j.com/docs/java-reference/current/extending-neo4j/customized-code/

[abstract]
{description}

[#cypher-extension]
== Extending Cypher

Cypher is a powerful and expressive language, with first class graph pattern and collection support.
But sometimes you need to do more than it currently offers, like additional graph algorithms, parallelization, or custom conversions.

That's why Neo4j and Cypher can be extended with link:https://neo4j.com/docs/java-reference/current/extending-neo4j/[_User-defined procedures and functions_].
Neo4j itself provides and utilizes custom procedures.
Many of the monitoring, introspection and security features exposed by Neo4j Browser are implemented using procedures.

image::procedures-functions-bolt.jpg[width=600]

[#procedures-functions]
== What are procedures and functions?

* Functions are simple computations / conversions and return a single value.
* Functions can be used in any expression or predicate.

* Procedures are more complex operations and generate streams of results.
* Procedures must be used within the `CALL` clause and `YIELD` their result columns.
* They can generate, fetch or compute data to make it available to later processing steps in your Cypher query.

[#cypher-list-extension]
== Listing & using functions and procedures

There are a link:https://neo4j.com/docs/operations-manual/current/reference/procedures/[number of built in procedures^], two of which are used to list available functions and procedures.

Run the following statements along to get a hang of the usage and see their results.

[source,cypher]
----
CALL dbms.procedures()
----

Call `dbms.functions()` to list functions.

Each procedure returns one or more columns of data.
With `yield` these columns can be selected and also aliased and are then available in your Cypher statement.

[source,cypher]
----
CALL dbms.procedures()
YIELD name, signature, description as text
WHERE name STARTS WITH 'db.'
RETURN * ORDER BY name ASC
----

Of course you can also process the result columns with other Cypher clauses.
Here we group them by package.

[source,cypher]
----
CALL dbms.procedures()
YIELD name, signature, description
WITH split(name,".") AS parts
RETURN parts[0..-1] AS package,  count(*) AS count,
       collect(parts[-1]) AS names
ORDER BY count DESC
----

[options=header]
|===
|package             |count  |names
|["dbms","security"] |16     |["activateUser","addRoleToUser","changePassword",....]
|["apoc","refactor"] |11     |["categorize","cloneNodes","from"....]
|["apoc","load"]     |9      |["csv","driver","jdbc","jdbcParams","json","jsoe"]
|["db"]              |9      |["awaitIndex","constraints","indexes","labels",..,"schema"]
|["dbms"]            |9      |["components","functions","queries","procedures",...]
|===

As of Neo4j 3.1, all functions available are directly part of the Cypher implementation, so user-defined Functions would only come from installed libraries.

You can take any procedure library and deploy it to your server to make additional procedures and functions available.

Also take a look at the link:https://neo4j.com/docs/java-reference/current/extending-neo4j/[procedure section in the Neo4j Java Reference^].

[#deploy-extension]
== Deploying procedures & functions

If you built your own procedures or downloaded them from a community project, they are packaged in a jar-file.
You can copy that file into the `$NEO4J_HOME/plugins` directory of your Neo4j server and restart.

[WARNING]
*A word of caution.*
As procedures and functions use the low level Java API they can access all Neo4j internals as well as the file system and machine.
That's why you should know which procedures you deploy and why.
Only install procedures from trusted sources.
If they are open source, check their source-code and best build them yourself.

[IMPORTANT]
Certain procedures and functions are available for self-managed Neo4j Enterprise Edition and Community Edition.  Custom code
described in this section is not compatible with link:{aura_signup}[AuraDB]

[#procedure-function-gallery]
== Procedure and function gallery

In our link:https://neo4j.com/labs/[Neo4j Labs projects], we provide an impressive set of libraries built by our community and staff.
Check it out to see what's already there.
Many of your needs will already be covered by those, for example:

* index operations
* database/api integration
* graph refactorings
* import and export
* spatial index lookup
* rdf import and export
* and many more

Here are two cool examples of what you can do:

A procedure to load data from another database:

[source,cypher]
-----
WITH "jdbc:mysql://localhost:3306/northwind?user=root" as url
CALL apoc.load.jdbc(url,"products") YIELD row
RETURN row
ORDER BY row.UnitPrice DESC
LIMIT 20
-----

image::https://raw.githubusercontent.com/neo4j-contrib/neo4j-apoc-procedures/3.2/docs/img/apoc-load-jdbc.jpg[]

Functions to format and parse timestamps of different resolutions:

[source,cypher]
----
RETURN apoc.date.format(timestamp()) as time,
       apoc.date.format(timestamp(),'ms','yyyy-MM-dd') as date,
       apoc.date.parse('13.01.1975','s','dd.MM.yyyy') as unixtime,
       apoc.date.parse('2017-01-05 13:03:07') as millis
----

[options="header,autowidth"]
|===
|time                 |date        |unixtime  |millis
|"2017-01-05 13:06:39"|"2017-01-05"|158803200 |1483621387000
|===

[#custom-extension]
== Developing your own procedures and functions

You can find details on writing and testing procedures in the link:https://neo4j.com/docs/java-reference/current/extending-neo4j/procedures-and-functions/introduction/[Neo4j Manual^].  
The https://github.com/neo4j-examples/neo4j-procedure-template[example GitHub repository^] contains detailed documentation and comments that you can clone directly and use as a starting point.

Here are just some initial tips:

User-defined functions are simpler, so let's start with them:

* `@UserFunction` are annotated, public Java methods in a class
* their default name is package-name.method-name
* they return a single value
* are read only

User defined procedures are similar:

* `@Procedure` annotated, Java methods
* with an additional `mode` attribute (`READ, WRITE, DBMS`)
* return a Java 8 `Stream` of simple objects with `public` fields
* these fields names are turned into result columns available for `YIELD`

These things are valid for both:

* take `@Name` annotated parameters (with optional default values)
* can use an injected `@Context public GraphDatabaseService`
* run within transaction of the Cypher statement
* supported types for parameters and results are: `Long, Double, Boolean, String, Node, Relationship, Path, Object`

