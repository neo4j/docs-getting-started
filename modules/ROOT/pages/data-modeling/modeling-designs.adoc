[[modeling-designs]]
= Modeling designs
:tags: graph-modeling, data-model, schema, model-design, modeling-decisions
:description: This page features examples of graph data modeling patterns and designs that are commonly used with Neo4j.

This page features examples of graph data modeling patterns and designs that are commonly used with Neo4j.
The purpose is to get an overview of the options available for building graphy data models and how known strategies can be adapted to your project.

== Multiple structures

You can combine multiple structures to create a data model.
Take this example:

image::multiple-structures.svg[Example graph using multiple structures to create a data model with timeline tree and employment events,width=600,role=popup]

This graph features:

* A xref:#_timeline_tree[timeline tree] which is subdivided into years and months at the top.
* Employment events are represented as `Employment` nodes, which are connected to the timeline and show the starting and the ending months.
* The `Employment` nodes are xref:#_intermediate_nodes[intermediate nodes] that connect people, companies, and job roles. 
In this case, the intermediate nodes are serving the dual purpose of reducing the density of `Person` nodes, and providing an attachment point for the timeline tree.
* Employment events that are organized into xref:#_linked_list[linked lists] for each person and represent a sequence of events in an individual’s career.
The graph shows overlaps in people's employment history.

The example shows how different structures can be combined into one graph, and how different types of questions can be answered by one single graph if you use the correct design, depending on the question.
It also shows the many ways nodes and structures can span out.

=== Monopartite

image::monopartite.svg[Example of monopartite graph structure,width=300,role=popup]

A monopartite graph structure consists of a single set of nodes with a single label.
Most algorithms rely on this type of graph and they are very common when using spanning trees, link:{docs-home}/cypher-manual/current/patterns/shortest-paths/[shortest paths], and link:{docs-home}/graph-data-science/current/algorithms/community/[community detection].

=== Bipartite

Bipartite structures contain nodes that can be divided into two sets, such that relationships only exist between sets but not within each set.
link:{docs-home}/graph-data-science/current/algorithms/node-similarity/[Node similarity algorithms] rely on this type of graph.

image::bipartite.svg[Example of bipartite graph structure,width=300,role=popup]

=== Multipartite

Multipartite structures contain multiple independent sets of nodes with many labels.
Real-world graph analysis often deals with multipartite networks.

image::multipartite.svg[Example of a multipartite structure featuring multiple independent sets of nodes, labels, and different relationships,width=600,role=popup]

== Intermediate nodes

Intermediate nodes are nodes that are needed, but often aren’t identified in the initial data model.
They are nodes that contain data that needs to be in the graph, but don't seem to fit in the beginning of the modeling process.

This kind of situation often occurs when you use a single relationship to connect *more* than two nodes.
While this is an acceptable strategy in mathematical graphs, which can use hyperedges, it is not supported in Neo4j.

One way to identify that you’re dealing with a potential hyperedge is when you want to locate something in a relationship rather than a node. 
For example, here there is a person who works at a company and there is information about their role:

image::hyperedge.svg[An example of a hyperedge in which a relationship is connected to two nodes, a feature not available in Neo4j,width=400,role=popup]

In a mathematical graph, you could use the same relationship `WORKED_AT` to connect the `Person` node with both `Role` and `Company` nodes.
However, in Neo4j, you can't do it.

Instead, you could either turn the `Role` node into a property of the `WORKED_AT` relationship or use an *intermediate node* between the `Person`, `Company`, and `Role` nodes:

image::refactored-hyperedge.svg[Instead of using one single relationship to both Company and Role nodes, an intermediary Employment node can solve the problem of incompatibility of hyperedges in Neo4j,width=500,role=popup]

In this new graph, instead of saying Patrick works at company Acme, it’s phrased as Patrick having an employment event, which becomes a new node.
The employment event holds the employment start and end dates, and logically relates to the other three nodes. 

Despite the idea of an employment event being an abstract idea, it provides a good way to link any amount of related additional information.

=== Sharing context

In this expanded version of the previous example, a new `Person` node with the name David has been added:

image::intermediate-nodes-employement-sharing-context-example.svg[Graph showing shared context between employment and company nodes,width=600,role=popup]

In this iteration, the `Person` nodes share context through `Role` and `Company` nodes.
The `Employment` nodes provide a way to trace details such as a person's career, or the overlap between different individuals at the same `Company`, or those who had the same `Role`.

This modeling design can also answer the question "Who has worked at the same company, at the same time?" as it contains information about when each individual worked at a certain company.
The question can be answered with a `MATCH` query that will show that Patrick and David both worked at Acme, being colleagues from 2004 to 2005.

=== Sharing data

Intemediate nodes can also add value to a model by providing a way to share data and thus reduce duplicate information.
By using a fanout, duplication can be reduced as a property (`content`) is split onto its own node (`Email` with the property `content`) instead of being repeated, for example, in this case, in relationships:

image::intermediate-nodes-employement-sharing-example.svg[Example of how to not repeat a same property by turning it into an intermediate node,width=600,role=popup]

Once the property value `content` is moved to a single node `Email`, it can be referenced via relationships with the `User` nodes that previously held that value.
Now there are no copies or duplications.

=== Organizing data

Intermediate nodes can also help organizing structures.
In this example, Sarah has sent emailed to several people:

image::sarah-emailed.svg[Graph showing how a user named Sarah emailed several other users,width=300,role=popup]

If every `EMAILED` relationship included a property with the content of the message, two problems can arise:

* *Sarah’s node is becoming very dense*: For every recipient of a message she writes, she gains another relationship.
* *It's expensive to retrieve the content of the email*: With the data modeled like this, it's very expensive to determine who in Sarah’s recipient network has received a given message.

By using intermediate nodes, you can have only one relationship per email, regardless of the number of recipients:

image::sarah-emailed-intermediate.svg[Updated graph with intemediate nodes for emails sent by Sarah to several other users,width=300,role=popup]

With this model, you can find the recepients by locating the specific `Email` node that now contains the content of the message and see which users are connected to it via `RECEIVED` and `TO` relationships.

While both models use a gather-and-inspect approach, the scope of the problem has been reduced significantly after the refactoring.
In the first iteration, if you wanted to see who received a certain email, you would need to check all users connected to Sarah via the `EMAILED` relationship.
In the second iteration, you only need to locate the correct `Email` node that you want to know more about, then traverse from it to all of the connected recipients.

In summary, you're likely to find many uses for intermediate nodes, but you might rarely recognize the need for them at the outset of the data modeling.
When refactoring and re-imagining the graph, however, they prove to be very useful.

== Linked list

Linked lists are commonly used in computer science and they are particularly useful whenever the sequence of objects matters.
Despite being a good practice to use verbs when creating a relationship, it is very common in this case to connect sequential items using terms such as "next" and "previous" instead.

With this strategy, you can have simple- or double-linked lists, but *you should never use a double-linked list in Neo4j*.
For example:

[cols="<,<",options="header"]
|===

a| **Correct: simple-linked list**
a| **Incorrect: double-linked list**

a| image::simple-linked-list.svg[Episodes of Dr Who linked in sequence with next relationships,role=popup]
a| image::double-linked-list.svg[Episodes of Dr Who doubly linked with next and previous relationships, an incorrect modeling design in Neo4j,role=popup]
|===

=== Interleaved linked list

There are different ways to sequence a list of items.
When nodes are connected in a nonlinear fashion, they are referred to as an interleaved linked list.

Interleaved lists are used when you want to sequence a set of list based on context, not necessarily a sequence in time.
This example combines a linked list with an interleaved linked list of Dr. Who episodes:

image::interleaved-list.svg[Example of interleaved list connecting Dr Who episodes with next and next in production relationships,width=700,role=popup]

The order in which TV episodes are aired is often different than the order in which they are produced.
This example contains five episodes of Dr. Who from season 12 and it shows:

* The order in which the episodes were aired using the `NEXT` relationship and through a simple-linked list.
* The order in which the episodes were produced using the `NEXT_IN_PRODUCTION` relationship, which creates an interleaved linked list.
It is not a linear list, as it goes 1, 3, 2, 5, 4.

Note that this example is *not* a double-linked list because it doesn't involve symmetry between the existing relationships connecting the items.

=== Head and tail of a linked list

When working with linked lists, there is often a “parent” node that is used as the entry point. 
The parent almost always points to the first item in the sequence, using an appropriately named relationship. 
Sometimes, another relationship points to the last item in a list.

In this example, you can see a first and a last relationship that stresses which are the first and the last episodes:

image::head-tail-list.svg[List of five Dr Who episodes from season twelve, showing the first and the last through a relationship with the season node,width=700,role=popup]

Some implementations also have a "progress" pointer that is used to keep track of the current node of interest.
This can be done through a relationship, for example:

image::latest-aired.svg[The latest aired episode is pointed with the help of a latest aired relationship coming from the season node,width=700,role=popup]

The progress pointer here is the `LATESTED_AIRED` relationship and it shows which was the most recently aired episode (i.e. "The Ark in Space").
When the `NEXT` episode ("The Sontaran Experiment") airs, the relationship is updated by deleting the current one and creating a new `LATEST_AIRED` pointer, so that it always points to the current item.

== Timeline tree

Timeline trees are useful whenever you want to use a time period.
This can be done by using an anchor, a navigational aid when querying, or when there are periods of time that are of interest relative to a query.

The division and length of the time periods are set based on the context of the question.
Also known as the "all time node", the topmost node in the timeline tree spans the entire timeline and then splits into whatever time period is relevant.

This example features subdivisions for each branch in years, months, and days, and how they connect to `Purchase` nodes:

image::timeline-tree.svg[Graph with two different timeslines divided in years, months, and days and what purchases are connected to these dates,width=600,role=popup]

This timeline tree structure shows how otherwise expensive queries can be answered more quickly.
For instance, if you want to find all purchases that happened at a given time period, such as every purchase in the month of December 2012, you only need to:

. Navigate from the 2012 `Year` node to December (`Month` node with the property value "12").
. Fetch everything from the connected leaf nodes under that branch.

If you were, instead, dealing with time as a navigator, but not as the anchor, and you wanted to answer the same question, you would need to:

. Start by finding the event of a specific purchase.
. Find all other purchases within a year.
. Start a leaf node for the original purchase.
. Traverse into the timeline tree, going up to the year of interest.
. Go back down the tree, fetching all relevant data while descending it. 

Without a timeline tree in the graph, a same question could require a great deal of property lookups and a lot of inefficient gather-and-inspect.

== Time-bound data

One way to model time-specific data and relationships is by including data in the relationship type.
Because Neo4j is optimized specifically for traversing relationships between entities, you can often improve query performance by specifying a date as the relationship type and only traversing particular dated relationships.

A common example is modeling airline flights:

image::airport.svg[Example graph connecting airport nodes through a flying to relationship,width=500,role=popup]

This could be a first iteration showing what flights happen between airports.
Now, suppose you want to know about an airline in particular and how many flights it performed during a specific date.
This particular model is not very efficient as you would need to scan for this information through all properties of the `FLYING_TO` relationship and, in reality, airports perform multiple flights from several airlines everyday.

So instead of performing an expensive query, you could refactor the graph to add xref:#_intermediate_nodes[intermediate nodes].
In this case, you can create an intermediate node `Flight` between the `Airport` nodes, and another one, `AirportDay`, between the `Airport` and `Flight` nodes:

image::flight.svg[Refactored graph with intermediate nodes,width=600,role=popup]

With this xref:data-modeling/graph-model-refactoring.adoc[refactored design], you can look only at the relationships for dates you care about and then scan for the relevant airline through the `Airline` property in the `Flight` node.

Despite the improvement, this model is still not the most optimal design, but it is nevertheless an iteration.
When such changes are performed, it can be important to keep track of them by versioning your model.

// Content on versioning is WIP.