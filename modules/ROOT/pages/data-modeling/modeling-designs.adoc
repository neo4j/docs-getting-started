[[modeling-designs]]
= Modeling designs
:tags: graph-modeling, data-model, schema, model-design, modeling-decisions
:description: This page features examples of graph data modeling patterns and designs that are commonly used with Neo4j.

This page features examples of graph data modeling patterns and designs that are commonly used with Neo4j.
The purpose is to get an overview of the options available for building graph data models and how known strategies can be adapted to your project.

== Intermediate nodes

Intermediate nodes are often not identified in the initial data model, but added during refactoring to improve performance of your graph.
They are nodes that contain data that needs to be in the graph, but don't seem to fit neatly anywhere in the beginning of the modeling process.

You could solve the problem by using a single relationship to connect *more* than two nodes.
This type of relationship is called a *hyperedge* and these are used in mathematical graphs.
However, hyperedges are *not* supported in Neo4j and can instead be refactored into *intermediate nodes*.

One way to identify that you’re dealing with a potential hyperedge is when you want to contain information in a relationship rather than a node. 
For example, consider a person who works at a company and you need to convey information about their role:

image::hyperedge.svg[An example of a hyperedge in which a relationship is connected to two nodes, a feature not available in Neo4j,width=400,role=popup]

In a mathematical graph, you could use the same relationship `WORKED_AT` to connect the `Person` node with both `Role` and `Company` nodes.
However, in Neo4j, you can't do it.

Instead, you could either turn the `Role` node into a property of the `WORKED_AT` relationship or use an *intermediate node* between the `Person`, `Company`, and `Role` nodes:

image::refactored-hyperedge.svg[Instead of using one single relationship to both Company and Role nodes, an intermediary Employment node can solve the problem of incompatibility of hyperedges in Neo4j,width=500,role=popup]

In this new graph, instead of saying Patrick works at company Acme, it’s phrased as Patrick having an employment event, which becomes a new node.
The employment event holds the employment start and end dates, and logically relates to the other three nodes. 

Despite the idea of an employment event being an abstract idea, it provides a good way to link any amount of related additional information.

=== Sharing context

In this expanded version of the previous example, a new `Person` node with the name David is added:

image::intermediate-nodes-employement-sharing-context-example.svg[Graph showing shared context between employment and company nodes,width=600,role=popup]

In this iteration, the `Person` nodes share context through `Role` and `Company` nodes.
The `Employment` nodes provide a way to trace details such as a person's career, or the overlap between different individuals at the same `Company`, or those who had the same `Role`.

This modeling design can also answer the question "Who worked at the same company at the same time?" as it contains information about when each individual worked at a certain company.
The question can be answered with a `MATCH` query that will show that Patrick and David both worked at Acme, being colleagues from 2004 to 2005.

=== Sharing data

Intemediate nodes can also add value to a model by providing a way to share data and thus reduce duplicate information.
By using a fan-out, duplication can be reduced as a property (`content`) is broken out and made into its own node (`Email` with the property `content`) instead of being repeated, in this case, on every relationship:

image::intermediate-nodes-employement-sharing-example.svg[Example of how to not repeat a same property by turning it into an intermediate node,width=600,role=popup]

Once the property value `content` is moved to a single node `Email`, it can be referenced via relationships with the `User` nodes that previously held that value.
Now there are no copies or duplications.

=== Organizing data

Intermediate nodes can also help organize structures.
In this example, Sarah sent the same email message to several people:

image::sarah-emailed.svg[Graph showing how a user named Sarah emailed several other users,width=300,role=popup]

If every `EMAILED` relationship included a property with the content of the message, two problems can arise:

* *Sarah’s node is becoming very dense*: For every recipient of a message she adds, her node gains another relationship.
* *It's expensive to retrieve the content of the email*: With the data modeled like this, it's very expensive to determine who in Sarah’s recipient network has received a given message by searching for the content in multiple 'EMAILED' relationships.

By adding intermediate nodes to represent each email message, Sarah's node has only one relationship per email message, regardless of the number of recipients:

image::sarah-emailed-intermediate.svg[Updated graph with intemediate nodes for emails sent by Sarah to several other users,width=300,role=popup]

With this model, you can find the recepients by locating the specific `Email` node that now contains the content of the message in the `content` property, and then see which users are connected to it via `TO` relationships.

While both models use a gather-and-inspect approach, the scope of the problem is reduced significantly after the refactoring.
In the first iteration, if you want to see who received a certain email, you need to find all users connected to Sarah via the `EMAILED` relationship.
In the second iteration, you only need to locate the correct `Email` node, then traverse from it to all of the connected recipients.

In summary, you're likely to find many uses for intermediate nodes during refactoring since you rarely recognize the need for them at the outset of the data modeling.

== Linked list

Linked lists are commonly used in computer science and they are particularly useful whenever the sequence of objects matters.
It is good practice to use verbs as relationship types, however, it is very common with linked lists to connect sequential items using terms such as "next" and "previous" instead.

In this data structure, a simple-linked list is where each node links to the next node only, whereas in a double-linked list, each node links both to the next and the previous node.
Neo4j *does not* support double-linked lists.
For example:

[cols="<,<",options="header"]
|===

a| **Supported: simple-linked list**
a| **Not supported: double-linked list**

a| image::simple-linked-list.svg[Episodes of Dr Who linked in sequence with next relationships,role=popup]
a| image::double-linked-list.svg[Episodes of Dr Who doubly linked with next and previous relationships, an incorrect modeling design in Neo4j,role=popup]
|===

=== Interleaved linked list

A list of items is not always sequential.
When nodes are connected in a nonlinear fashion, they are referred to as an interleaved linked list.

Interleaved lists are used when you want to sequence a set of list based on context, not necessarily a sequence in time.
This example combines a linked list with an interleaved linked list of Dr. Who episodes:

image::interleaved-list.svg[Example of interleaved list connecting Dr Who episodes with next and next in production relationships,width=700,role=popup]

The order in which TV episodes are aired is often different than the order in which they are produced.
This example contains five episodes of Dr. Who from season 12 and it shows:

* The order in which the episodes were aired using the `NEXT` relationship and through a simple-linked list.
* The order in which the episodes were produced using the `NEXT_IN_PRODUCTION` relationship, which creates an interleaved linked list.
It is not a linear list, as it goes 1, 3, 2, 5, 4.

Note that this example is *not* a double-linked list because it doesn't involve symmetry between the existing relationships connecting the items.

=== Head and tail of a linked list

When working with linked lists, there is often a “parent” node that is used as the entry point. 
The parent almost always points to the first item in the sequence, using an appropriately named relationship. 
Sometimes, another relationship points to the last item in a list.

In this example, you can see a `FIRST` and a `LAST` relationship, referring to their places in the sequence:

image::head-tail-list.svg[List of five Dr Who episodes from season twelve, showing the first and the last through a relationship with the season node,width=700,role=popup]

Some implementations also have a "progress" pointer that is used to keep track of the current node of interest.
This can be done through a relationship, for example:

image::latest-aired.svg[The latest aired episode is pointed with the help of a latest aired relationship coming from the season node,width=700,role=popup]

The progress pointer here is the `LATEST_AIRED` relationship and it shows which was the most recently aired episode (i.e. "The Ark in Space").
When the `NEXT` episode ("The Sontaran Experiment") airs, the relationship is updated by deleting the current one and creating a new `LATEST_AIRED` pointer, so that it always points to the current item.

== Timeline tree

Timeline trees are useful when your queries are time-related.
To create a timeline tree, you can use an anchor, which is a navigational aid that you add when querying or when there are periods of time that are of interest relative to a query.
Anchors can be a starting/parent node or an entity that you can use as a reference point (e.g. a date).

The division and length of the time periods are set based on the context of the question you need to answer.
On the top of the timeline tree is the "all time node" that represents the entire timeline.
The timeline is then divided into relevant time periods, represented by the nodes below the all time node.

This example features subdivisions for each branch in years, months, and days, and how they connect to `Purchase` nodes:

image::timeline-tree.svg[Graph with two different timeslines divided in years, months, and days and what purchases are connected to these dates,width=600,role=popup]

This timeline tree structure shows how otherwise expensive queries can be answered more quickly.
For instance, if you want to find all purchases that happened at a given time period, such as every purchase in the month of December 2012, you only need to:

. Navigate from the 2012 `Year` node to December (`Month` node with the property value "12").
. Fetch everything from the connected leaf nodes (that is, nodes with no descendants) under that branch.

If you were, instead, working with a data model with no timeline tree, this same question could require a great deal of property lookups and a lot of inefficient gather-and-inspect.

== Time-bound data

Another way to model time-specific data and relationships is by including data in the relationship type.
Because Neo4j is optimized for traversing relationships between entities, you can often improve query performance by using a date as the relationship type and only traversing relationships with a particular date.

A common example is modeling airline flights:

image::airport.svg[Example graph connecting airport nodes through a flying to relationship,width=500,role=popup]

This could be a first iteration showing what flights happen between airports.
Now, suppose you want to know about a particular airline and how many flights it had on a specific date.
The described model is not very efficient as you would need to scan all properties of the `FLYING_TO` relationship and, in reality, airports have multiple flights operated by many different airlines everyday.

So instead of performing an expensive query, you could refactor the graph and add xref:#_intermediate_nodes[intermediate nodes].
In this case, you can create an intermediate node `Flight` between the `Airport` nodes, and another one, `AirportDay`, between the `Airport` and `Flight` nodes:

image::flight.svg[Refactored graph with intermediate nodes,width=600,role=popup]

With this xref:data-modeling/tutorial-refactoring.adoc[refactored design], you can look only at the relationships for dates you care about and then scan for the relevant airline through the `airline` property in the `Flight` node.

This is an improvement, but the model is still not optimal and should be iterated on.
When changes are done to your model, it is important to keep track of them by versioning your model.

// Content on versioning is WIP.


== Multiple structures

You can combine multiple graph structures to create a data model.
Take this example:

image::multiple-structures.svg[Example graph using multiple structures to create a data model with timeline tree and employment events,width=600,role=popup]

This graph features:

* A xref:#_timeline_tree[timeline tree] which is divided into years and months subsequently at the top.
* Employment events are represented as `Employment` nodes, which are connected to the timeline and show the starting and the ending months.
* The `Employment` nodes are xref:#_intermediate_nodes[intermediate nodes] that connect people, companies, and job roles. 
In this case, the intermediate nodes are serving the dual purpose of reducing the density of `Person` nodes, and providing an attachment point for the timeline tree.
* Employment events that are organized into xref:#_linked_list[linked lists] for each person and represent a sequence of events in an individual’s career.
The graph shows overlaps in people's employment history.

The example shows how different structures can be combined into one graph, and how different types of questions can be answered by one single graph if the modeling is done efficiently.
It also shows the many ways nodes and structures can span out.

=== Monopartite

image::monopartite.svg[Example of monopartite graph structure,width=300,role=popup]

A monopartite graph structure consists of a single set of nodes with a single label.
Most algorithms rely on this type of graph and they are very common when using spanning trees, link:{docs-home}/graph-data-science/current/algorithms/page-rank/[PageRank], link:{docs-home}/graph-data-science/current/algorithms/eigenvector-centrality/[Eigenvector], and link:{docs-home}/graph-data-science/current/algorithms/community/[community detection].

=== Bipartite

Bipartite structures contain nodes that can be divided into two sets, such that relationships only exist between sets but not within each set.
link:{docs-home}/graph-data-science/current/algorithms/node-similarity/[Node similarity algorithms] rely on this type of graph.

image::bipartite.svg[Example of bipartite graph structure,width=300,role=popup]

=== Multipartite

Multipartite structures contain multiple independent sets of nodes with many labels.
Real-world graph analysis often deals with multipartite networks.

image::multipartite.svg[Example of a multipartite structure featuring multiple independent sets of nodes, labels, and different relationships,width=600,role=popup]
