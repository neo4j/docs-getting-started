[[modeling-designs]]
= Modeling designs
:tags: graph-modeling, data-model, schema, model-design, modeling-decisions
:description: Learn how to represent graph data using a variety of modeling decisions. The way you construct your data model can impact your queries and performance.

Evaluating your model and making appropriate changes to your data is an important step in the data modeling process.
Also known as xref:data-modeling/graph-model-refactoring.adoc[refactoring], this step can help you define the best solution for your use case and maximize the performance of your queries.

This page shows tips and designs that you can use as inspiration for when you create a data model with Neo4j, so you learn how certain model decisions can impact queries and performance for traversing graph data.

[#property-vs-relationship]
== Property vs relationship

One of the earliest decisions you may encounter is whether to model something as a property on a node or as a relationship connecting nodes.

In the xref:data-modeling/tutorial-refactoring.adoc#_remaining_or_new_use_cases[Tutorial: Refactor a graph data model], for example, languages in a movie were changed from a node property (`movie.languages`) to a node (`Language`) that is connected via a relationship (`IN_LANGUAGE`).

[options=header,cols="1a,1a"]
|===

| Before
| After

| image::movie-languages.svg[Graph with person and movie nodes connected through acted in and directed relationships, now with added property for movie languages, 500, 500, role=popup]
| image::language-nodes.svg[Refactored graph with new language nodes for English, Italian, and Latin connected to their respective movie nodes through an in language relationship, role=popup]

|===

Neither version of the data model is worse or better, but the best option depends on the types of queries you intend to run against your data.
For example:

* If you plan to analyze individual items and return only details about that entity (like languages in a particular movie), then the first data model ("Before") would serve perfectly well for your needs.
* If you need to run analysis to find common ground between entities or look at a group of nodes, then the second data model would definitely improve performance of those types of queries.

[TIP]
====
Remember that the goal in data modeling is to reduce the size of the graph that is touched by a query.
====

[#complex-models]
== Complex data structures

As many of us can probably agree, not all data models are simple and straightforward.
Data is messy, and the model must attempt to better-organize it to help us see patterns and make decisions.

One excellent example of a complex data structure that is difficult to model is Marvel comic data.
In the Marvel universe, there are comics that have characters who make appearances or play lead roles.
Comics can be organized into a series of particular storylines or narratives for a certain time, and major events can take place in a comic that define a character path or series.
Creators (including writers, illustrators, etc) are the authors of comics, defining storyline, character adaptations, and events that happen.
Multiple creators can also participate interchangeably to create a comic or series.

This dataset already seems complicated, with several entities and relationships at work.
It adds a new layer of complexity when trying to model the hierarchies and intermediate entities that exist here.

If you have some time, you can view the full video link to https://player.vimeo.com/video/79399404[Peter's presentation^] on Vimeo, but we want to highlight two key challenges that Peter discusses in the data set.

First, he found that comic characters tend to be extremely dynamic.
Many characters cannot be identified by name or costume or any particular property, as all of those change often.

Second, Peter identified the issue of chronology.
For those new to the comic universe, some might want to determine where to start or what comic(s) come next.
However, comic issues are not always sequentially numbered, and there are even some storylines that appear across multiple series and back again.
This makes it incredibly difficult to separate certain blocks of stories or events, along with renditions of characters.

=== Example: intermediate nodes

One modeling technique that is useful in this model is the concept of a hyperedge.
Hyperedges are often created to model relationships that exist between more than two entities.
Neo4j doesn't support relationships between more than two nodes and instead uses intermediate nodes to model this kind of relationship.
They are often created to represent the connection of multiple entities at a point in time.

A common example of this is a university course.
There may be multiple offerings of the same course with the same instructor in the same building, etc.
Each section of the class (or offering) would then become an instance of the course.

The way Peter at Marvel handled intermediate nodes in their data is by creating an `Appearance` node that represents the intersection of a `Person` and an `Alias` at a particular time.
This `Appearance` can be related to multiple `Moment` nodes where the person and alias appear as a unit.
This is represented in the model shown below (also in the https://player.vimeo.com/video/79399404[video^]).

.Graph model of a Marvel character
image::modeling_marvel_hyperedge_appearance-arr.svg[role="popup-link",550,550]

In a relational store, attempting to categorize and relate all of these complicated aspects would be extremely difficult and further complicate analysis and review of the data as a whole.
The graph model allowed them to model this heavily dynamic universe and track all of the changing connections throughout their data.
For this use case, graph was the perfect fit.

[#model-time-versions]
== Time-bound data and versioning

One way to model time-specific data and relationships is by including data in the relationship type.
Because Neo4j is optimized specifically for traversing relationships between entities, you can often improve query performance by specifying a date as the relationship type and only traversing particular dated relationships.

A common example is for modeling airline flights.
An airline has a particular flight on a certain day from and to a specific location.
We might start with a model like the _Figure 4_ below to show how flights travel from airport to airport.

.Graph model for airline flights
image::modeling_airport_flights-arr.svg[role="popup-link",450,450]

We would soon realize that we need to model a `Flight` entity that exists between two destinations because multiple planes can travel between two destinations several times in one day.

However, your queries probably still show the model's weakness in filtering through all of the flights at a specific airport - especially for London and other major cities that have hundreds of flights connected to an `Airport` node over any span of time.
Inspecting the several properties of each `Flight` node could be expensive on resources.

If we were to create a node for a particular airport day and a relationship with a date in the type, then we could write queries to find flights from an airport on any specified date (or date range).
This way, you wouldn't need to check each flight relationship to an airport.
Instead, you would only look at the relationships for the dates you cared about.
This model turns out like the one below.

.Graph model for airline flights after review
image::modeling_airport_flight_dates-arr.svg[role="popup-link",600,600]

For the full walkthrough of the modeling process for airline flights, see link:https://maxdemarzi.com/2015/08/26/modeling-airline-flights-in-neo4j/[Blog post: Modeling Airline Flights in Neo4j^].

=== Versioning

Similar to the model above where we create a dated relationship type, we can also use this to track versions of our data.
Tracking changes in the data structure or showing a current and past value can be incredibly important for auditing purposes, trend analysis, etc.

For instance, if you wanted to create a new effective-dated relationship between a person and their current address, but also retain past addresses, you could use the same principle of including a date in the relationship type.
To find the current address of the person, the query would look for the most recently dated relationship.

[#multiple-models]
== Taking the best of both worlds

Sometimes, you might find that one model works really well for one scenario you need, but another model is better for something else.
For instance, some models will perform better with write queries and other models handle read queries better.
Both capabilities are important to your use case, so what do you do?

In these cases, you can combine both models and use the benefits of each.
Yes, you can use more than one data model in your graph!

The tradeoff is that now you will need to maintain two models.
Each time you create a new node or relationship or update pieces of the graph, you will need to make changes to accommodate both models.
This can also impact query performance, as you might have double the syntax needed to update each model.

While this is definitely a possible option, you should know the maintenance costs and evaluate whether those costs are overcome by the performance improvements you will see for each needed query.
If so, being able to use more than one data model is a great solution!

[#modeling-resources]
== Resources
* https://medium.com/neo4j/graph-data-modeling-all-about-relationships-5060e46820ce[Blog post: Modeling relationships^]
* https://maxdemarzi.com/2015/08/26/modeling-airline-flights-in-neo4j/[Max's blog post: Modeling airline flights^]
* https://maxdemarzi.com/2017/05/24/flight-search-with-neo4j/[Follow-up blog post: Flight search^]
* https://medium.com/neo4j/graph-data-modeling-categorical-variables-dd8a2845d5e0[Blog post: Modeling data categories^]
* https://maxdemarzi.com/2017/11/21/mutual-fund-benchmarks-with-neo4j/[Blog post: Modeling mutual funds^]
* https://maxdemarzi.com/2018/07/11/building-a-dating-site-with-neo4j-part-one/[Blog post series: Building a Dating Site^]
* https://maxdemarzi.com/2017/03/30/building-a-twitter-clone-with-neo4j-part-one/[Blog series: Building a Twitter Clone^]
* https://community.neo4j.com/[Ask Questions on the Neo4j Community Site!^]
