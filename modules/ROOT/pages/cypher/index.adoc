[[cypher-intro]]
= What is Cypher
:description: A high-level overview of the graph query language Cypher.
:page-ad-overline-link: https://graphacademy.neo4j.com/courses/cypher-fundamentals
:page-ad-overline: Neo4j GraphAcademy
:page-ad-title: Cypher Fundamentals
:page-ad-description: Learn Cypher in this free, hands-on course
:page-ad-link: https://graphacademy.neo4j.com/courses/cypher-fundamentals
:page-ad-underline-role: button
:page-ad-underline: Learn more

[IMPORTANT]
====
This page covers the basics of Cypher.
For the complete documentation, refer to the link:{docs-home}/cypher/[Cypher Manual].
====

.A visual representation of a Cypher query
image::cypher-learning-arr.svg[role="popup-link",width=450]

Cypher is Neo4j's declarative and link:https://neo4j.com/docs/cypher-manual/current/appendix/gql-conformance/[GQL conformant] query language. 
Available as open source via link:http://openCypher.org[The openCypher project], Cypher is link:{docs-home}/cypher-manual/current/introduction/cypher-overview/#_cypher_and_sql_key_differences[similar to SQL], but optimized for graphs.

Intuitive and close to natural language, Cypher provides a visual way of matching patterns and relationships by having its own design based on ASCII-art type of syntax:

[source,cypher]
----
(:nodes)-[:ARE_CONNECTED_TO]->(:otherNodes)
----

Round brackets are used to represent `(:Nodes)`, and square brackets `-[]->` to represent a relationship between the `(:Nodes)`.
With this query syntax, you can perform create, read, update, or delete (CRUD) operations on your graph.

[TIP]
====
To try querying with Cypher, get a free link:https://neo4j.com/cloud/platform/aura-graph-database/[Aura instance], no installation required.
Use the graduation cap icon on the top right section to access the interactive guides.
The "Query fundamentals" gives you a hands-on introduction to Cypher.
====

== How does Cypher work?

The graph is composed of <<nodes>> and <<relationships>>, which may also have assigned <<properties>>.
With nodes and relationships, you can build a graph that can express both simple and complex patterns.

Pattern recognition is a key fundamental cognitive process.
With Cypher, you can use pattern matching, which in turn makes the learning process more intuitive.

[#cypher-syntax]
== Cypher syntax

ifndef::backend-pdf[]
++++
<div class="responsive-embed">
<iframe width="560" height="315" src="https://www.youtube.com/embed/_dup3YOZSm8" title="What is Cypher?" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>
++++
endif::[]

ifdef::backend-pdf[]
link:https://www.youtube.com/watch?v=_dup3YOZSm8[What is Cypher?]
endif::[]

Cypher's constructs are close to natural language and the syntax is designed to visually look like a graph.

.A graph example involving four nodes and three relationships.
image::cypherintro-graph.svg[role="popup-link",width=600]

If you want to represent the data in this graph in English, it would read as something like: _"Sally likes Graphs. Sally is friends with John. Sally works for Neo4j."_

Now, if you were to write this same information in Cypher, then it would look like this:

[source, cypher]
----
(:Sally)-[:LIKES]->(:Graphs)
(:Sally)-[:IS_FRIENDS_WITH]->(:John)
(:Sally)-[:WORKS_FOR]->(:Neo4j)
----

With this query, you turn the information into nodes and relationships, which are the core elements of Cypher.

=== Nodes

The main components in a graph are nodes and relationships.
Nodes are often used to represent nouns or objects in your data model.
In the previous example, `Sally`, `John`, `Graphs`, and `Neo4j` are the nodes:

.A visual representation of nodes.
image::cypherintro-nodes.svg[role="popup-link",width=450]

As mentioned previously, nodes are represented as round brackets `(node)` in Cypher.
The parentheses are a representation of the circles that compose the nodes in the visualization.

==== Node labels

Nodes can be grouped together through a <<label>>, which works like a tag and allows you to specify certain types of entities in your queries.
Labels help Cypher distinguish between nodes and optimize execution.

In the example, both `Sally` and `John` are persons, so they get a `Person` label, `Graphs` gets a `Technology` label, and `Neo4j` is a `Company`:

.Nodes grouped by labels. Note that `Sally`, `John`, `Graphs`, and `Neo4j` are now xref:cypher/index.adoc#cypher-properties[properties] instead.
image::cypher-graph-nodes-arr.svg[role="popup-link",width=450]

In a relational database context, this would be the same as using SQL to refer to a particular row in a table.
The same way you can use SQL to query a person's information from a `Person` table, you can also use the `Person` label for that information in Cypher.

[CAUTION]
====
If you do not specify a label for Cypher to filter out non-matching node categories, the query will check all of the nodes in the database.
This can affect performance in very large graphs.
====

==== Node variables

If part of your query matches nodes that you need to reference in a later part of your query (i.e. in a *subclause*), you can use *node variables*.
If part of your query matches nodes that you need to reference in a later part of your query (i.e. in a link:https://neo4j.com/docs/cypher-manual/current/clauses/#reading-sub-clauses[subclause]), you can use *node variables*.

Variables can be single letters or words, and should be written in lower-case.
For example, if you want to bind all nodes labeled `Person` to the variable `p`, you write `(p:Person)`.
If you want to use a full word as a variable, `(person:Person)` works exactly the same.

.Retrieve all Person nodes
[source, cypher]
----
MATCH (p:Person)
RETURN p
----

[#cypher-relationships]
=== Relationships

In a graph database, both nodes and relationships are first-class citizens and they have equal value. 
In a relational database, relationships are only implied via foreign keys and join tables.

In Cypher, relationships are represented as square brackets with an optional arrow to indicate the direction (e.g. `(Node1)-[]->(Node2)`).

In the example, the arrows connecting the nodes represent the relationship between the nodes:

.Graph featuring nodes and relationships.
image::cypherintro-graph.svg[]


==== Relationship directions

Relationships *always* have a direction which is indicated by an arrow.

They can go from left to right:

[source,cypher]
----
(p:Person)-[:LIKES]->(t:Technology)
----

From right to left:

[source,cypher]
----
(p:Person)<-[:LIKES]-(t:Technology)
----

Or be undirected (where the direction is *not* specified):

[source,cypher]
----
MATCH (p:Person)-[:LIKES]-(t:Technology)
----

==== Undirected relationships

An undirected relationship does not mean that it doesn't have a direction, but that it can be traversed in *either* direction.
While you can't *create* relationships without a direction, you can *query* them undirected (in the example, using the link:{docs-home}/cypher-manual/current/clauses/match/[`MATCH`] clause).

Since Cypher won't return anything if you write a query with the wrong direction, you can use undirected relationships in queries when you don't know the direction.
This way, Cypher will retrieve *all* nodes connected by the specified relationship type, regardless of direction.

[NOTE]
====
Because undirected relationships in queries are traversed twice (once for each direction), the same pattern will be returned twice.
This may impact the performance of the query.
====

==== Relationship types

Relationship types categorize and add meaning to a relationship, similar to how labels group nodes together.
It is considered best practice to use verbs or derivatives for the relationship type.
The type describes how the nodes relate to each other.
This way, Cypher is almost like natural language, where nodes are the subjects and objects (nouns), and the relationships (verbs) are the predicates that relate them.

In the previous example, the relationship types are:

* `[:LIKES]` - communicates that Sally (a node) _likes_ graphs (another node).
* `[:IS_FRIENDS_WITH]` - communicates that Sally _is friends with_ John.
* `[:WORKS_FOR]` - communicates that Sally _works for_ Neo4j.

[IMPORTANT]
====
Remember to always put a colon in front of a relationship type.
If you write `(Person)-[LIKES]->(Technology)`, `[LIKES]` will represent a relationship *variable*, not a relationship *type*.
In this case, since no relationship type is declared, Cypher's `RETURN` clause will search for all types of relationships in order to retrieve a result to your query.
====

==== Relationship variables

Variables can be used for relationships in the same way as for nodes. 
Once you specify a variable, you can use it later in the query to reference the relationship.

Take this example:

[source,cypher]
----
MATCH (p:Person)-[r:LIKES]->(t:Technology)
RETURN p,r,t
----

This query specifies variables for both the node labels (`p` for `Person` and `t` for `Technology`) and the relationship type (`r` for `:LIKES`).
In the return clause, you can then use the variables (i.e. `p`, `r`, and `t`) to return the bound entities.

This would be your result:

.Result for the example query using node and relationship variables.
image::cypherintro-variables.svg[]

.Result
[role="queryresult",options="header,footer",cols="3*<m"]
|===
| p | r | t

| (:Person) | [:LIKES]  | (:Technology)

3+d|Rows: 1
|===

[#cypher-properties]
=== Properties

Properties are used to store additional information and can be added both to nodes and relationships and be of a variety of data types.
For a full list of values and types, see link:{docs-home}/cypher-manual/current/values-and-types/[Cypher manual -> Values and types].

In the following example, `sally` and `john` are xref:cypher/index.adoc##_node_variables[variables] for `Person` nodes which contain a `name` property with the *property values* "Sally" and "John":

.Graph example with node and relationship properties.
image::cypherintro-properties.svg[]

To add this info to the graph, you can use the following query:

[source,cypher]
----
CREATE (sally:Person {name:'Sally'})-[r:IS_FRIENDS_WITH]->(john:Person {name:'John'})
RETURN sally, r, john
----

Properties are enclosed by curly brackets (`{}`), the key is followed by a colon, and the value is enclosed by single or double quotation marks.

In case you have already added Sally and John as node labels, but want to change them into node properties, you need to refactor your graph.
Refactoring is a strategy in link:{docs-home}/model[data modeling] that you can learn more about in link:{docs-home}/getting-started/data-modeling/graph-model-refactoring/[this tutorial].

[#cypher-patterns]
=== Patterns in Cypher

Graph pattern matching sits at the very core of Cypher. 
It is the mechanism used to navigate, describe, and extract data from a graph by applying a declarative pattern.

Consider this example:

[source, cypher]
----
(sally:Person {name:'Sally'})-[l:LIKES]->(g:Technology {type: "Graphs"})
----

This bit of Cypher represents a pattern.
It expresses that a `Person` node with _Sally_ as its `name` property has a `LIKES` relationship to the `Technology` node with _Graphs_ as its `type` property.

You can use this pattern in different queries to the database by adding a keyword to make it a *clause*.

For example, you can add this information to the database with the link:{docs-home}/cypher-manual/current/clauses/create/[`CREATE`] clause:

[source, cypher]
--
CREATE (sally:Person {name: "Sally"})-[r:LIKES]->(t:Technology {type: "Graphs"})
--

And once this data is written to the database, you can retrieve it with this pattern:

[source, cypher]
--
MATCH (sally:Person {name: "Sally"})-[r:LIKES]->(t:Technology {type: "Graphs"})
RETURN sally,r,t
--

==== Pattern variables

In the same way as nodes and relationships, you can also use variables for patterns.
Considering the previous example, you can turn the whole pattern (`(Sally)-[:LIKES]->(Technology)`) into a variable (`p`):

[source,cypher]
--
MATCH p = (sally:Person {name: "Sally"})-[r:LIKES]->(t:Technology {type: "Graphs"})
RETURN p
--

For more information, refer to link:{docs-home}/cypher-manual/current/patterns/reference/[Cypher manual -> Patterns -> Syntax and Semantics].

== Keep learning

If you want to learn more about writing Cypher queries, you can take the tutorial on how to xref:cypher/intro-tutorial.adoc[Get started with Cypher].
In the link:{docs-home}/cypher-manual[Cypher manual], you can find more information on:

* How to write link:{docs-home}/cypher-manual/current/queries/basic/[basic queries] and what link:{docs-home}/cypher-manual/current/clauses/[clauses] you can use to read data from the database.
* How link:{docs-home}/cypher-manual/current/patterns/[patterns] work and how you can use them to navigate, describe and extract data from a graph.
* What link:{docs-home}/cypher-manual/current/values-and-types/[values and types], and link:{docs-home}/cypher-manual/current/functions/[functions] are available in Cypher.

=== From SQL to Cypher

In case you have a background in SQL and are new to graph databases, these are some resources for more information on the key differences and the transition to graphs:

* link:{docs-home}/cypher-manual/current/introduction/cypher-overview/#_cypher_and_sql_key_differences[Key differences between Cypher and SQL]
* xref:reference/graphdb-vs-rdbms[Transition from relational to graph database]
* xref:cypher/cypher-sql.adoc[Reference: Comparing Cypher with SQL]
* xref:data-import/relational-to-graph-import.adoc[How-to: Import from RDBMS into graph]
* xref:data-import/import-relational-and-etl.adoc[Tutorial: Import data from a relational database into Neo4j]
* link:data-modeling/relational-to-graph-modeling.adoc[How-to: Model data from relational to graph]

=== From NoSQL to Graphs

If you are familiar with NoSQL ("Not only SQL") system, you can also learn more on xref:appendix/graphdb-concepts/graphdb-vs-nosql.adoc[how to make the transition] to a graph database.

=== GraphAcademy

With the link:https://graphacademy.neo4j.com/courses/cypher-fundamentals/[Cypher Fundamentals] course, you can learn Cypher in 60 minutes and practice using a sandbox.

=== Other resources

For more suggestions on how to expand your knowledge about Cypher, refer to xref:appendix/getting-started-resources.adoc[Resources].

ifndef::backend-pdf[]
[discrete.glossary]
endif::[]
== Glossary

include::ROOT:glossary.adoc[]

ifdef::backend-pdf[]
<<<
endif::[]
