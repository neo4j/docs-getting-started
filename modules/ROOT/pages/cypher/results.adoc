= Refining results
:description: This guide describes how to refine the results from Cypher queries.
:page-ad-overline-link: https://graphacademy.neo4j.com/courses/cypher-fundamentals
:page-ad-overline: Neo4j GraphAcademy
:page-ad-title: Cypher Fundamentals
:page-ad-description: Learn Cypher in this free, hands-on course
:page-ad-link: https://graphacademy.neo4j.com/courses/cypher-fundamentals
:page-ad-underline-role: button
:page-ad-underline: Learn more

This guide describes how to manipulate the output of Cypher queries in order to get the refined results.

== Example dataset

After you create a link:https://neo4j.com/product/auradb/?ref=docs-nav-get-started[free Aura instance], use the "Connect" button and select "Query". 
In the Cypher editor, copy and paste the following Cypher and execute the query:

[source,cypher, indent=0]
----
CREATE (matrix:Movie {title: 'The Matrix', released: 1997})
CREATE (cloudAtlas:Movie {title: 'Cloud Atlas', released: 2012})
CREATE (forrestGump:Movie {title: 'Forrest Gump', released: 1994})
CREATE (larryCrowne:Movie {title: 'Larry Crowne', released: 2011})
CREATE (keanu:Person {name: 'Keanu Reeves', born: 1964})
CREATE (robert:Person {name: 'Robert Zemeckis', born: 1951})
CREATE (tom:Person {name: 'Tom Hanks', born: 1956})
CREATE (tom)-[:ACTED_IN {roles: ['Forrest']}]->(forrestGump)
CREATE (tom)-[:ACTED_IN {roles: ['Zachry']}]->(cloudAtlas)
CREATE (tom)-[:ACTED_IN {roles: ['Larry Crowne']}]->(larryCrowne)
CREATE (tom)-[:DIRECTED]->(larryCrowne)
CREATE (robert)-[:DIRECTED]->(forrestGump)

CREATE (diana:Person {name: "Diana"})
CREATE (melissa:Person {name: "Melissa", twitter: "@melissa"})
CREATE (dan:Person {name: "Dan", twitter: "@dan", yearsExperience: 6})
CREATE (sally:Person {name: "Sally", yearsExperience: 4})
CREATE (john:Person {name: "John", yearsExperience: 5})
CREATE (jennifer:Person {name: "Jennifer", twitter: "@jennifer", yearsExperience: 5})
CREATE (joe:Person {name: "Joe"})
CREATE (mark:Person {name: "Mark", twitter: "@mark"})
CREATE (ann:Person {name: "Ann"})
CREATE (xyz:Company {name: "XYZ"})
CREATE (x:Company {name: "Company X"})
CREATE (a:Company {name: "Company A"})
CREATE (Neo4j:Company {name: "Neo4j"})
CREATE (abc:Company {name: "ABC"})
CREATE (query:Technology {type: "Query Languages"})
CREATE (etl:Technology {type: "Data ETL"})
CREATE (integrations:Technology {type: "Integrations"})
CREATE (graphs:Technology {type: "Graphs"})
CREATE (dev:Technology {type: "Application Development"})
CREATE (java:Technology {type: "Java"})
CREATE (diana)-[:LIKES]->(query)
CREATE (melissa)-[:LIKES]->(query)
CREATE (dan)-[:LIKES]->(etl)<-[:LIKES]-(melissa)
CREATE (xyz)<-[:WORKS_FOR]-(sally)-[:LIKES]->(integrations)<-[:LIKES]-(dan)
CREATE (sally)<-[:IS_FRIENDS_WITH]-(john)-[:LIKES]->(java)
CREATE (john)<-[:IS_FRIENDS_WITH]-(jennifer)-[:LIKES]->(java)
CREATE (john)-[:WORKS_FOR]->(xyz)
CREATE (sally)<-[:IS_FRIENDS_WITH]-(jennifer)-[:IS_FRIENDS_WITH]->(melissa)
CREATE (joe)-[:LIKES]->(query)
CREATE (x)<-[:WORKS_FOR]-(diana)<-[:IS_FRIENDS_WITH]-(joe)-[:IS_FRIENDS_WITH]->(mark)-[:LIKES]->(graphs)<-[:LIKES]-(jennifer)-[:WORKS_FOR {startYear: 2017}]->(Neo4j)
CREATE (ann)<-[:IS_FRIENDS_WITH]-(jennifer)-[:IS_FRIENDS_WITH]->(mark)
CREATE (john)-[:LIKES]->(dev)<-[:LIKES]-(ann)-[:IS_FRIENDS_WITH]->(dan)-[:WORKS_FOR]->(abc)
CREATE (ann)-[:WORKS_FOR]->(abc)
CREATE (a)<-[:WORKS_FOR]-(melissa)-[:LIKES]->(graphs)<-[:LIKES]-(diana)
----

== Filter

You can filter results and return only a subset of data by using the link:https://neo4j.com/docs/cypher-manual/current/clauses/where/[`WHERE`] subclause or the link:https://neo4j.com/docs/cypher-manual/current/clauses/filter/[`FILTER`] (available only in Cypher 25) clause, in some cases.

=== Property

You can check which people have Twitter handles by filtering results via a property.
You could do this by writing the following query:

[source,cypher]
--
MATCH (p:Person) 
RETURN p.name, p.twitter
--

Since only four `Person` nodes out of 12 contain a value for the property `twitter`, you also retrieve another 8 `null` results.

In Neo4j, properties only exist (are stored) if they have a value.
A `null` property value is not stored.
This ensures that only valuable, necessary information is retained for your nodes and relationships.

To return only results that contain a value, you can use the `WHERE` subclause and specify that it returns only results that are not `null`:

[source, cypher]
--
MATCH (p:Person)
WHERE p.twitter IS NOT NULL
RETURN p.name;
--

Or, alternatively, use `FILTER` with Cypher 25:

[source, cypher]
--
CYPHER 25
MATCH (p:Person)
FILTER p.twitter IS NOT NULL
RETURN p.name;
--

[IMPORTANT]
====
You need to include `CYPHER 25` in the beginning of your query if you are using an earlier version of Cypher.
This does *not* change the default language version, it only ensures that this query runs in Cypher 25.
Otherwise, the clause `FILTER`, which is exclusive to this Cypher version, won't work.

To see a comparison between `FILTER` and `WHERE`, refer to link:https://neo4j.com/docs/cypher-manual/current/clauses/filter/#filter-where-differeces[Cypher -> `FILTER`].
====

The result is:

[role="queryresult",options="header,footer",cols="1*<m"]
|===
| p.name

| "Melissa"
| "Dan"
| "Jennifer"
| "Mark"

1+d|Rows: 4
|===

=== Strings and partial values

You can filter results based on parts of the value stored in a node or relationship using specific link:https://neo4j.com/docs/cypher-manual/current/expressions/[expressions] together with `WHERE`:

==== `STARTS WITH`

The `STARTS WITH` operator searches for property values that begin with a string you specify, for example, the letter "M":

[source,cypher]
--
MATCH (p:Person)
WHERE p.name STARTS WITH 'M'
RETURN p.name;
--

In this case, the result is: 

[role="queryresult",options="header,footer",cols="1*<m"]
|===
| p.name

| "Melissa"
| "Mark"

1+d|Rows: 2
|===

==== `CONTAINS`

The `CONTAINS` operator checks if a specified string is part of a property value, for example, if it contains the letter "a":

[source,cypher]
--
MATCH (p:Person)
WHERE p.name CONTAINS 'a'
RETURN p.name;
--

The result is:

[role="queryresult",options="header,footer",cols="1*<m"]
|===
| p.name

| "Diana"
| "Melissa"
| "Dan"
| "Sally"
| "Mark"

1+d|Rows: 5
|===

[NOTE]
====
If you still have the xref:cypher/results.adoc#_filter_results[Movies example dataset] added to your graph, you will see the names "Keanu Reeves" and "Tom Hanks" in the list too, thus 7 rows.
====

==== `ENDS_WITH`

The `ENDS_WITH` operator searches for a specified value at the end of a property value, for example, a value that ends with "n": 

[source, cypher]
--
MATCH (p:Person)
WHERE p.name ENDS WITH 'n'
RETURN p.name;
--

The result is:

[role="queryresult",options="header,footer",cols="1*<m"]
|===
| p.name

| "Dan"
| "John"
| "Ann"

1+d|Rows: 3
|===

Alternatively, you can use regular expressions, without string operators, to find a property value.
For example, if you want to find any names that include "Jo" and be case sensitive:

[source, cypher]
----
MATCH (p:Person)
WHERE p.name =~ 'Jo.*'
RETURN p.name
----

[role="queryresult",options="header,footer",cols="1*<m"]
|===
| p.name

| "John"
| "Joe"

1+d|Rows: 2
|===

==== `IN`

With the `IN` operator, you can specify an array of values and validate a property.
For example, if any `Person` node in the graph has "1", "5" or "6" values for `yearsExperience`:

[source, cypher]
--
MATCH (p:Person)
WHERE p.yearsExperience IN [1, 5, 6]
RETURN p.name, p.yearsExperience
--

The result shows that no one has 1 year of experience, but three people have 5 and 6:

[role="queryresult",options="header,footer",cols="2*<m"]
|===
| p.name | p.yearsExperience

| "Dan"
| 5

| "John"
|6

| "Jennifer"
| 5

2+d|Rows: 3
|===

=== Patterns

Besides filtering queries through node labels and properties, you can also filter results based on relationships or patterns.
This allows you to test if a pattern also has a certain relationship and/or if another pattern exists.

For example, if you query which people are friends with someone who works for Neo4j, you can write it like this:

[source, cypher]
--
MATCH (p:Person)-[r:IS_FRIENDS_WITH]->(friend:Person) 
WHERE exists((p)-[:WORKS_FOR]->(:Company {name: 'Neo4j'})) 
RETURN p, r, friend;
--

Which gives you the result:

image::cypher-filter-exists-ptrn-arr.svg[Graph showing how Jennifer is connected to Ann, Mark, Sally, Melissa and John through a is friends with relationship, role=popup, width=400]

You can also query for patterns that *don't exist*.
For example, if you want to find which of Jennifer's friends do not work for any company, use the following query:

[source, cypher]
--
MATCH (p:Person)-[r:IS_FRIENDS_WITH]->(friend:Person)
WHERE p.name = 'Jennifer'
AND NOT exists((friend)-[:WORKS_FOR]->(:Company))
RETURN friend.name;
--

You get only "Mark" as the result.

==== `OPTIONAL` patterns

There are cases when you want to retrieve results from patterns, even if they do not match the entire pattern or all criteria.
For that, you can first use an `OPTIONAL MATCH` and, if there are no results, the query returns `null` as values.

For example, if you search for people whose name starts with a "J" and who may work for a company:

[source, cypher]
--
MATCH (p:Person)
WHERE p.name STARTS WITH 'J'
OPTIONAL MATCH (p)-[:WORKS_FOR]-(other:Company)
RETURN p.name, other.name;
--

You get the following result:

[role="queryresult",options="header,footer",cols="2*<m"]
|===
| p.name | other.name

| "Jennifer"
| "Neo4j"

| "John"
| "XYZ"

| "Joe"
| null

2+d|Rows: 3
|===

Notice that Joe is returned because his name starts with the letter 'J', but his company's name is `null`.
This is because he does not have a `WORKS_FOR` relationship to a `COMPANY` node.
Since you used `OPTIONAL MATCH`, his `Person` node is still returned from the first match, but the optional match is not found, so it returns `null`.

To see the difference, try running the query without the `OPTIONAL` in front of the second match.
Joe's row is no longer returned in the result.
This is because Cypher reads the statement with an `AND` match, so the person must match the first criterium (name starts with "J") and the second criterium (person works for a company).

==== More complex patterns

You can use queries with patterns that have more than one relationship.
For example, if you want to know who else likes graphs besides Jennifer, you can use this query:

[source, cypher]
--
MATCH (j:Person {name: 'Jennifer'})-[r:LIKES]-(graph:Technology {type: 'Graphs'})-[r2:LIKES]-(p:Person)
RETURN p.name;
--

The result is:

[role="queryresult",options="header,footer",cols="1*<m"]
|===
| p.name

| "Diana"
| "Melissa"
| "Mark"

1+d|Rows: 3
|===

Another possibility is finding which people who like graphs is also friends with Jennifer:

[source, cypher]
--
MATCH (j:Person {name: 'Jennifer'})-[:LIKES]->(:Technology {type: 'Graphs'})<-[:LIKES]-(p:Person),
      (j)-[:IS_FRIENDS_WITH]-(p)
RETURN p.name;
--

The result is:

[role="queryresult",options="header,footer",cols="1*<m"]
|===
| p.name

| "Melissa"
| "Mark"

1+d|Rows: 2
|===

Notice that the second query has a comma at the end of the first line, and another pattern is added to `MATCH` on the next line.
This allows you to query different patterns together, similarly to when you used link:http://localhost:8000/getting-started/cypher/results/#_patterns[`WHERE exists(<pattern>)`] previously.

With this structure, you can add multiple different patterns and link them together, allowing you to traverse various pieces of the graph with certain patterns.

For more advanced information on how to query patterns, see link:https://neo4j.com/docs/cypher-manual/current/patterns/[Cypher -> Patterns].

== Compare results

=== Equality

You can use comparisons to filter values, starting with equality: 

[source, cypher]
--
MATCH (m:Movie)
WHERE m.title = 'The Matrix'
RETURN m
--

[role="queryresult",options="header,footer",cols="1*<m"]
|===
| m

| (:Movie {title: 'The Matrix', released: 1997})

1+d|Rows: 1
|===

=== Numeric

Another option is the numeric comparison.
Here you match regular expressions, and confirm the existence of values within a list. 

The `WHERE` clause in the following example includes a regular expression match, a greater-than comparison, and a test to see if a value exists in a list:

[source, cypher]
--
MATCH (p:Person)-[r:ACTED_IN]->(m:Movie)
WHERE p.name =~ 'K.+' OR m.released > 2000 OR 'Neo' IN r.roles
RETURN p, r, m
--

Based on the given logical operator `OR` and the graph pattern `(p:Person)-[r:ACTED_IN]->(m:Movie)`, the query result has to meet *one* of the following requirements:

* The person's `name` starts with the letter `'K'`.
* The movie was released after the year `2000`.
* The role is `'Neo'`.

In the example dataset, only one match of the pattern `(p:Person)-[r:ACTED_IN]->(m:Movie)` meets _any_ of the conditions, therefore the output is the following:

image::tomhanks-cloudatlas.svg[Tom Hanks' node is connected to Cloud Atlas' node through the acted in relationship, width=400, role=popup]

You can also use patterns as predicates to further filter or refine results.
While the `MATCH` clause *expands* the number and shape of patterns matched, a pattern predicate *restricts* the result.

If you append `NOT` to the `WHERE` clause, it only returns paths that do *not* satisfy the specified pattern:

[source, cypher]
--
MATCH (p:Person)-[:DIRECTED]->(m)
WHERE NOT (p)-[:ACTED_IN]->()
RETURN p, m
--

The result is:

image::robert-forrest.svg[Nodes for Robert Zemeckis and Forrest Gump, width=200, role=popup]

This is because the query looks for `Person` nodes that are connected to `Movie` nodes through the `DIRECTED` relationship *only* and *not* `ACTED_IN`.
If the `ACTED_IN` relationship isn't a restriction anymore:

[source, cypher]
--
MATCH (p:Person)-[:DIRECTED]->(m)
RETURN p, m
--

Then the result would now include Tom Hanks and the movie "Larry Crowne" because he has directed *and* acted the movie:

image::tomrobert-movies.svg[Tom Hanks and Robert Zemeckis's nodes and the Forrest Gump and Larry Crowne movie nodes, width=400, role=popup]

== Range of values

You can query data within a certain range in number or date, for example, if you want to find events within a certain timeline, age values, etc.

image::workplace-graph.svg[Graph including people connected with each other through is friends with relationships, connected to company nodes through works at relationships, and connected to technology nodes with likes relationships, width=800, role=popup]

If you want to know who has experience within the range of three to seven years:

[source, cypher]
--
MATCH (p:Person)
WHERE 3 <= p.yearsExperience <= 7
RETURN p
--

The result is:

image::cypher-filter-ranges-arr.svg[width=400, role="popup-link"]

== Aliasing results

By default, Cypher returns a label as the name of the column in the tabular results.
However, you can use an alias to make the results more understandable by using `AS`.

For example, if you want to have the tabular result with a column titled `name` instead of the label `p.name`:

[source, cypher]
--
MATCH (p:Person)
RETURN p.name AS name
--

Optionally, you can also use the `WITH` clause for that:

[source, cypher]
--
MATCH (p:Person)
WITH p.name AS name
RETURN name
--

If you have both the "Movie" and the "Workplaces" datasets in your graph, the tabular result is:

[role="queryresult",options="header,footer",cols="1*<m"]
|===
| name

| "Keanu Reeves" | "Robert Zemeckis" | "Tom Hanks"
| "Diana" | "Melissa" | "Dan"
| "Sally" | "John" | "Jennifer"
| "Joe" | "Mark" | "Ann"

1+d|Rows: 12
|===

== Avoiding duplication

For example, if you want to know which people are connected through a `IS_FRIENDS_WITH` with each other, you could write the query like this:

[source, cypher]
--
MATCH (p:Person)-[:IS_FRIENDS_WITH]->(friend:Person)
RETURN friend.name;
--

And the result is:

[role="queryresult",options="header,footer",cols="1*<m"]
|===
| friend.name

| "Sally"
| "Melissa"
| "Sally"
| "John"
| "Mark"
| "Ann"
| "Diana"
| "Mark"
| "Dan"

1+d|Rows: 9
|===

Note that "Sally" appears twice.
This is because she is connected to two different people through two `IS_FRIENDS_WITH` relationships.
To avoid this duplication, you can add `DISTINCT` after `RETURN`:

[source, cypher]
--
MATCH (p:Person)-[:IS_FRIENDS_WITH]->(friend:Person)
RETURN DISTINCT friend.name;
--

Optionally, you can use `WITH`:

[source,cypher]
--
MATCH (p:Person)-[:IS_FRIENDS_WITH]->(friend:Person)
WITH DISTINCT friend.name as friendName
RETURN friendName
--

The result is now:

[role="queryresult",options="header,footer",cols="1*<m"]
|===
| friend.name

| "Sally"
| "Melissa"
| "John"
| "Mark"
| "Ann"
| "Diana"
| "Mark"
| "Dan"

1+d|Rows: 8
|===

== Order

If you want to get results ordered, you can use the clause link:https://neo4j.com/docs/cypher-manual/current/clauses/order-by/[`ORDER BY`] after `RETURN`.
For example, to list how many years of experience each person has in descending order:

[source, cypher]
--
MATCH (p:Person)
RETURN p.yearsExperience AS yearsExperience
ORDER BY yearsExperience DESC
--

Optionally, you can also use `WITH` together with `ORDER BY`:

[source, cypher]
--
MATCH (p:Person)
WITH p
ORDER BY p.yearsExperience DESC
RETURN p.yearsExperience AS yearsExperience
--

This is the result:

[role="queryresult",options="header,footer",cols="1*<m"]
|===

| yearsExperience

| null | null | null | null | null | null | null | null
| 6 | 5 | 5 | 4

1+d|Rows: 12
|===

Note that the first 8 rows contain `null` as result.
This means the property `yearsExperience` doesn't exist to all `Person` nodes, but existing entries are ordered in descending order, as stated in the query.

Optionally, you can avoid returning `null` values by using `WHERE` and `IS NOT NULL`:

[source, cypher]
--
MATCH (p:Person)
WHERE p.yearsExperience IS NOT NULL
RETURN p.yearsExperience AS yearsExperience
ORDER BY yearsExperience DESC
--

== Limit

You can use `LIMIT` when you want to restrict the number of results returned:
For example, the current example graph has 12 `Person` nodes.
If you want to retrieve only 3, you can write the following query:

[source, cypher]
--
MATCH (p:Person)
RETURN p
LIMIT 3
--

The result is:

[role="queryresult",options="header,footer",cols="1*<m"]
|===

| p

| (:Person {born: 1964, name: "Keanu Reeves"})
| (:Person {born: 1951, name: "Robert Zemeckis"})
| (:Person {born: 1956, name: "Tom Hanks"})

1+d|Rows: 3
|===

== Aggregate

Cypher provides several link:https://neo4j.com/docs/cypher-manual/current/functions/aggregating/[aggregating functions].
You can use them with the `RETURN` or the `WITH` clauses to aggregate results.

[options=header,cols="1,4"]
|===

| Function | Description

| link:https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-avg[`avg()`]
| Returns the average of a set of `INTEGER`, `FLOAT` or `DURATION` values.

| link:https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-collect[`collect()`]
| Returns a list containing the values returned by an expression.

| link:https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-count[`count()`]
| Returns the number of values or rows.

| link:https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-max[`max()`]
| Returns the maximum value in a set of values.

| link:https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-min[`min()`]
| Returns the minimum value in a set of values.

| link:https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-percentilecont[`percentileCont()`]
| Returns the percentile of a value over a group using linear interpolation.

| link:https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-percentiledisc[`percentileDisc()`]
| Returns the nearest `INTEGER` or `FLOAT` value to the given percentile over a group using a rounding method.

| link:https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-stdev[`stDev()`]
| Returns the standard deviation for the given value over a group for a sample of a population.

| link:https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-stdevp[`stDevP()`]
| Returns the standard deviation for the given value over a group for an entire population.

| link:https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-sum[`sum()`]
| Returns the sum of a set of INTEGER, FLOAT or DURATION values.

|===

Refer to link:https://neo4j.com/docs/cypher-manual/current/functions/aggregating/[Cypher -> Aggregating] for the complete list of all aggregating functions and examples.

== Unwind

If you have a list that you want to inspect or separate the values, Cypher offers the link:https://neo4j.com/docs/cypher-manual/current/clauses/unwind/[`UNWIND`] clause for that.
It does the opposite of link:https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-collect[`collect()`] and separates a list into individual values on separate rows.

For example, if you want to see which people in the example graph like "Graphs" and/or "Query Languages":

[source, cypher]
--
WITH ['Graphs','Query Languages'] AS likedTech
UNWIND likedTech AS technology
MATCH (p:Person)-[r:LIKES]-(t:Technology {type: technology})
RETURN t.type, collect(p.name) AS people;
--

Note that `UNWIND` is combined with link:https://neo4j.com/docs/cypher-manual/current/clauses/with/[`WITH`] and used *before* the `MATCH` clause.

The result of this query is:

[role="queryresult",options="header,footer",cols="2*<m"]
|===

| t.type | people

| "Graphs"
| ["Diana", "Melissa", "Jennifer", "Mark"]

| "Query Languages"
| ["Diana", "Melissa", "Joe"]

2+d|Rows: 2
|===

== Number of items

If you have a list of elements, you can also return the number of elements in that list using the link:https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-size[`size()`] function.

For example, if you want to know how many friends each person in the graph has:

[source, cypher]
--
MATCH (p:Person)-[:IS_FRIENDS_WITH]-(friend:Person)
RETURN p.name, size(collect(friend.name)) AS numberOfFriends;
--

The result is:

[role="queryresult",options="header,footer",cols="2*<m"]
|===

| p.name | numberOfFriends

| "Diana"
| 1

| "Melissa"
| 1

| "Dan"
| 1

| "Sally"
| 2

| "John"
| 2

| "Jennifer"
| 5

| "Joe"
| 2

| "Mark"
| 2

| "Ann"
| 1

2+d|Rows: 9
|===

Note that if you add a direction to the relationship:

[source, cypher]
--
MATCH (p:Person)-[:IS_FRIENDS_WITH]->(friend:Person)
RETURN p.name, size(collect(friend.name)) AS numberOfFriends;
--

You get a different result:

[role="queryresult",options="header,footer",cols="2*<m"]
|===

| p.name | numberOfFriends

| "John"
| 1

| "Jennifer"
| 5

| "Joe"
| 2

| "Ann"
| 1

2+d|Rows:4
|===

This is because not all `Person` nodes are connected through this direction of the `IS_FRIENDS_WITH` relationship.
Therefore, if you want an accurate answer to the question on how many friends each person has, you should not add a direction to the relationship in your query.

== Composed queries

There are different ways to combine separate query branches within a single query:

[options=header,cols="1,4"]
|===

| Function | Description

| link:https://neo4j.com/docs/cypher-manual/current/queries/composed-queries/combined-queries/[`UNION`]
| Combines the results of two or more queries into a single result set that includes all the rows that belong to any queries in the union.

| link:https://neo4j.com/docs/cypher-manual/current/queries/composed-queries/conditional-queries/[`WHEN`] label:cypher[Cypher 25 only] label:new[Introduced in Neo4j 2025.06]
| Together with `THEN` and `ELSE`, it enables different branches of a query to execute based on certain conditions. 

| link:https://neo4j.com/docs/cypher-manual/current/queries/composed-queries/sequential-queries/[`NEXT`] label:cypher[Cypher 25 only] label:new[Introduced in Neo4j 2025.06]
| Allows for linear composition of queries into a sequence of smaller, self-contained segments, passing the whole table of intermediate results from one segment to the next.

|===

== Keep learning

Cypher has many other resources for getting more accurate results.
If you want to keep learning, see the following pages:

. link:https://neo4j.com/docs/cypher-manual/current/clauses/skip/[`SKIP`] -> Defines from which row to start including the rows in the output.
. link:https://neo4j.com/docs/cypher-manual/current/expressions//[Expressions] -> Operators and expressions that can be used to evaluate values.
. link:https://neo4j.com/docs/cypher-manual/current/functions/[Functions] -> Full list of existing Cypher functions.
. link:https://neo4j.com/docs/cypher-manual/current/indexes/[Indexes] -> Strategies for speeding up data retrieval.
