= Refining results
:description: This guide describes how to refine the results from Cypher queries.
:page-ad-overline-link: https://graphacademy.neo4j.com/courses/cypher-fundamentals
:page-ad-overline: Neo4j GraphAcademy
:page-ad-title: Cypher Fundamentals
:page-ad-description: Learn Cypher in this free, hands-on course
:page-ad-link: https://graphacademy.neo4j.com/courses/cypher-fundamentals
:page-ad-underline-role: button
:page-ad-underline: Learn more

This guide describes how to refine the results from Cypher queries by filtering, ordering, comparing, aliasing, and more.

== Example dataset

After you create a link:https://neo4j.com/product/auradb/?ref=docs-nav-get-started[free Aura instance], use the "Connect" button and select "Query". 
In the Cypher editor, copy and paste the following Cypher and execute the query:

[source,cypher, indent=0]
----
CREATE (matrix:Movie {title: 'The Matrix', released: 1997})
CREATE (cloudAtlas:Movie {title: 'Cloud Atlas', released: 2012})
CREATE (forrestGump:Movie {title: 'Forrest Gump', released: 1994})
CREATE (larryCrowne:Movie {title: 'Larry Crowne', released: 2011})
CREATE (keanu:Person {name: 'Keanu Reeves', born: 1964})
CREATE (robert:Person {name: 'Robert Zemeckis', born: 1951})
CREATE (tom:Person {name: 'Tom Hanks', born: 1956})
CREATE (tom)-[:ACTED_IN {roles: ['Forrest']}]->(forrestGump)
CREATE (tom)-[:ACTED_IN {roles: ['Zachry']}]->(cloudAtlas)
CREATE (tom)-[:ACTED_IN {roles: ['Larry Crowne']}]->(larryCrowne)
CREATE (tom)-[:DIRECTED]->(larryCrowne)
CREATE (robert)-[:DIRECTED]->(forrestGump)

CREATE (diana:Person {name: "Diana"})
CREATE (melissa:Person {name: "Melissa", twitter: "@melissa"})
CREATE (dan:Person {name: "Dan", twitter: "@dan", yearsExperience: 6})
CREATE (sally:Person {name: "Sally", yearsExperience: 4})
CREATE (john:Person {name: "John", yearsExperience: 5})
CREATE (jennifer:Person {name: "Jennifer", twitter: "@jennifer", yearsExperience: 5})
CREATE (joe:Person {name: "Joe"})
CREATE (mark:Person {name: "Mark", twitter: "@mark"})
CREATE (ann:Person {name: "Ann"})
CREATE (xyz:Company {name: "XYZ"})
CREATE (x:Company {name: "Company X"})
CREATE (a:Company {name: "Company A"})
CREATE (Neo4j:Company {name: "Neo4j"})
CREATE (abc:Company {name: "ABC"})
CREATE (query:Technology {type: "Query Languages"})
CREATE (etl:Technology {type: "Data ETL"})
CREATE (integrations:Technology {type: "Integrations"})
CREATE (graphs:Technology {type: "Graphs"})
CREATE (dev:Technology {type: "Application Development"})
CREATE (java:Technology {type: "Java"})
CREATE (diana)-[:LIKES]->(query)
CREATE (melissa)-[:LIKES]->(query)
CREATE (dan)-[:LIKES]->(etl)<-[:LIKES]-(melissa)
CREATE (xyz)<-[:WORKS_FOR]-(sally)-[:LIKES]->(integrations)<-[:LIKES]-(dan)
CREATE (sally)<-[:IS_FRIENDS_WITH]-(john)-[:LIKES]->(java)
CREATE (john)<-[:IS_FRIENDS_WITH]-(jennifer)-[:LIKES]->(java)
CREATE (john)-[:WORKS_FOR]->(xyz)
CREATE (sally)<-[:IS_FRIENDS_WITH]-(jennifer)-[:IS_FRIENDS_WITH]->(melissa)
CREATE (joe)-[:LIKES]->(query)
CREATE (x)<-[:WORKS_FOR]-(diana)<-[:IS_FRIENDS_WITH]-(joe)-[:IS_FRIENDS_WITH]->(mark)-[:LIKES]->(graphs)<-[:LIKES]-(jennifer)-[:WORKS_FOR {startYear: 2017}]->(Neo4j)
CREATE (ann)<-[:IS_FRIENDS_WITH]-(jennifer)-[:IS_FRIENDS_WITH]->(mark)
CREATE (john)-[:LIKES]->(dev)<-[:LIKES]-(ann)-[:IS_FRIENDS_WITH]->(dan)-[:WORKS_FOR]->(abc)
CREATE (ann)-[:WORKS_FOR]->(abc)
CREATE (a)<-[:WORKS_FOR]-(melissa)-[:LIKES]->(graphs)<-[:LIKES]-(diana)
----

== Filter

You can filter results and return only a subset of data by using the link:https://neo4j.com/docs/cypher-manual/current/clauses/where/[`WHERE`] subclause or the link:https://neo4j.com/docs/cypher-manual/current/clauses/filter/[`FILTER`] (available only in Cypher 25) clause.

=== Property

You can filter results by *property*.
For example, to find which people in the example dataset have Twitter handles, you can use the following query:

[source,cypher]
--
MATCH (p:Person) 
RETURN p.name, p.twitter
--

Since you `MATCH` *all* `Person` nodes, they are all returned, regardless of whether they have a `twitter` property or not.
Out of the 12 `Person` nodes in the graph, only four (Melissa, Dan, Jennifer, Mark) contain a value for the `twitter` property.
Since the query matches and returns *all* `Person` nodes, you get another eight `null` results.

In Neo4j, properties only exist (are stored) if they have a value.
A `null` property value is not stored.
This ensures that only valuable, necessary information is retained for your nodes and relationships.

To return only results that contain a value, you can use the `WHERE` subclause and specify that it returns only results that are not `null`:

[source, cypher]
--
MATCH (p:Person)
WHERE p.twitter IS NOT NULL
RETURN p.name;
--

Or, alternatively, use `FILTER` with Cypher 25:

[source, cypher]
--
CYPHER 25
MATCH (p:Person)
FILTER p.twitter IS NOT NULL
RETURN p.name;
--

[IMPORTANT]
====
You need to include `CYPHER 25` in the beginning of your query if you are using an earlier version of Cypher.
This does *not* change the default language version, it only ensures that this query runs in Cypher 25.
Otherwise, the clause `FILTER`, which is exclusive to this Cypher version, won't work.

To see a comparison between `FILTER` and `WHERE`, refer to link:https://neo4j.com/docs/cypher-manual/current/clauses/filter/#filter-where-differeces[Cypher -> `FILTER`].
====

The result is:

[role="queryresult",options="header,footer",cols="1*<m"]
|===
| p.name

| "Melissa"
| "Dan"
| "Jennifer"
| "Mark"

1+d|Rows: 4
|===

=== Strings and partial values

You can filter results based on parts of the value stored in a node or relationship using specific link:https://neo4j.com/docs/cypher-manual/current/expressions/predicates[predicates] together with `WHERE`:

==== `STARTS WITH`

The `STARTS WITH` operator searches for property values that begin with a string you specify, for example, the letter "M":

[source,cypher]
--
MATCH (p:Person)
WHERE p.name STARTS WITH 'M'
RETURN p.name;
--

The result is: 

[role="queryresult",options="header,footer",cols="1*<m"]
|===
| p.name

| "Melissa"
| "Mark"

1+d|Rows: 2
|===

==== `CONTAINS`

The `CONTAINS` operator checks if a specified string is part of a property value, for example, if it contains the letter "a":

[source,cypher]
--
MATCH (p:Person)
WHERE p.name CONTAINS 'a'
RETURN p.name;
--

The result is:

[role="queryresult",options="header,footer",cols="1*<m"]
|===
| p.name

| "Keanu Reeves"
| "Tom Hanks"
| "Diana"
| "Melissa"
| "Dan"
| "Sally"
| "Mark"

1+d|Rows: 7
|===

==== `ENDS_WITH`

The `ENDS_WITH` operator searches for a specified string at the end of a property value, for example, a `name`  that ends with "n": 

[source, cypher]
--
MATCH (p:Person)
WHERE p.name ENDS WITH 'n'
RETURN p.name;
--

The result is:

[role="queryresult",options="header,footer",cols="1*<m"]
|===
| p.name

| "Dan"
| "John"
| "Ann"

1+d|Rows: 3
|===

Alternatively, you can use regular expressions, without string operators, to find a property value.
For example, if you want to find any names that include "Jo" while respecting case-sensitivity (queries are case sensitive by default):

[source, cypher]
----
MATCH (p:Person)
WHERE p.name =~ 'Jo.*'
RETURN p.name
----

[role="queryresult",options="header,footer",cols="1*<m"]
|===
| p.name

| "John"
| "Joe"

1+d|Rows: 2
|===

If you don't want your query to be case sensitive, you can use `toLower()` + `CONTAINS` and a value in lowercase:

[source, cypher]
--
MATCH (p:Person)
WHERE toLower(p.name) CONTAINS "jo"
RETURN p.name
--

Alternatively, using `toUpper()`:

[source, cypher]
--
MATCH (p:Person)
WHERE toUpper(p.name) CONTAINS "JO"
RETURN p.name
--

Both options return all `name` property values that contain "jo" no matter the letter case.

==== `IN`

With the `IN` operator, you can specify an array of values and validate a property.
For example, if any `Person` node in the graph has "1", "5" or "6" values for `yearsExperience`:

[source, cypher]
--
MATCH (p:Person)
WHERE p.yearsExperience IN [1, 5, 6]
RETURN p.name, p.yearsExperience
--

The result shows that no one has 1 year of experience, but three people have 5 and 6:

[role="queryresult",options="header,footer",cols="2*<m"]
|===
| p.name | p.yearsExperience

| "Dan"
| 5

| "John"
| 6

| "Jennifer"
| 5

2+d|Rows: 3
|===

=== Patterns

Besides filtering results on node labels and properties, you can also filter results based on relationships or patterns.
This allows you to test if a pattern also has a certain relationship and/or if another pattern exists.

For example, to find people who are friends with someone who works for Neo4j, you can filter on whether there exists a `[:WORKS_FOR]->(:Company {name:'Neo4j'})` relationship from the `p:Person` in the friendship:

[source, cypher]
--
MATCH (p:Person)-[r:IS_FRIENDS_WITH]->(friend:Person) 
WHERE exists((p)-[:WORKS_FOR]->(:Company {name: 'Neo4j'})) 
RETURN p, r, friend;
--

Which gives you the result:

image::cypher-filter-exists-ptrn-arr.svg[Graph showing how Jennifer is connected to Ann, Mark, Sally, Melissa and John through a is friends with relationship, role=popup, width=400]

You can also query for patterns that *don't exist*.
For example, if you want to find which of Jennifer's friends do not work for any company, use the following query:

[source, cypher]
--
MATCH (p:Person)-[r:IS_FRIENDS_WITH]->(friend:Person)
WHERE p.name = 'Jennifer'
AND NOT exists((friend)-[:WORKS_FOR]->(:Company))
RETURN friend.name;
--

You get only "Mark" as the result.

==== `OPTIONAL` patterns

Sometimes you want to return results from queries even if they don't meet all the criteria.
For that, you can use an `OPTIONAL MATCH` which returns null values where there is no match for the optional clause.

For example, if you search for people whose name starts with a "J" and who optionally work for a company:

[source, cypher]
--
MATCH (p:Person)
WHERE p.name STARTS WITH 'J'
OPTIONAL MATCH (p)-[:WORKS_FOR]-(other:Company)
RETURN p.name, other.name;
--

You get the following result:

[role="queryresult",options="header,footer",cols="2*<m"]
|===
| p.name | other.name

| "Jennifer"
| "Neo4j"

| "John"
| "XYZ"

| "Joe"
| null

2+d|Rows: 3
|===

Notice that Joe is returned because his name starts with the letter 'J', but his company's name is `null`.
This is because he does not have a `WORKS_FOR` relationship to a `COMPANY` node.
Since you used `OPTIONAL MATCH`, his `Person` node is still returned from the first match, but the optional match is not found, so a `null` result is returned for `other.name`.

To see the difference, try running the query without the `OPTIONAL` in front of the second match.
Joe's row is no longer returned in the result.
This is because Cypher reads the statement with an `AND` match, so the person must match the first criterium (name starts with "J") and the second criterium (person works for a company).

==== More complex patterns

You can query for patterns that have more than one relationship.
For example, if you want to know who else likes graphs besides Jennifer, you can use this query:

[source, cypher]
--
MATCH (j:Person {name: 'Jennifer'})-[r:LIKES]-(graph:Technology {type: 'Graphs'})-[r2:LIKES]-(p:Person)
RETURN p.name;
--

The result is:

[role="queryresult",options="header,footer",cols="1*<m"]
|===
| p.name

| "Diana"
| "Melissa"
| "Mark"

1+d|Rows: 3
|===

Another possibility is finding which people who like graphs is also friends with Jennifer:

[source, cypher]
--
MATCH (j:Person {name: 'Jennifer'})-[:LIKES]->(:Technology {type: 'Graphs'})<-[:LIKES]-(p:Person),
      (j)-[:IS_FRIENDS_WITH]-(p)
RETURN p.name;
--

The result is:

[role="queryresult",options="header,footer",cols="1*<m"]
|===
| p.name

| "Melissa"
| "Mark"

1+d|Rows: 2
|===

Notice that the second query has a comma at the end of the first line, and another pattern is added to `MATCH` on the next line.
This allows you to chain different patterns together, similar to when you used xref:cypher/results.adoc#_patterns[`WHERE exists(<pattern>)`] previously.

With this structure, you can add multiple different patterns and link them together, allowing you to traverse various pieces of the graph with certain patterns.

For more advanced information on how to query patterns, see link:https://neo4j.com/docs/cypher-manual/current/patterns/[Cypher -> Patterns].

== Compare values

=== Equality

You can use comparisons to filter values, starting with equality:

[source,cypher]
--
MATCH (m:Movie)
WHERE m.title = 'The Matrix'
RETURN m
--

The result is:

[role="queryresult",options="header,footer",cols="1*<m"]
|===
| m

| (:Movie {title: "The Matrix", released: 1997})

1+d|Rows: 1
|===

=== Numerical

Another option is the numerical comparison. 
Here you match regular expressions, and confirm the existence of values within a list.

The `WHERE` clause in the following example includes a greater-than comparison to find which movies were released after the year "2000":

[source, cypher]
--
MATCH (m:Movie)
WHERE m.released > 2000
RETURN m.title, m.released
--

The result is:

[role="queryresult",options="header,footer",cols="2*<m"]
|===
| m | m.release

| "Cloud Atlas"
| 2012

| "Larry Crowne"
| 2011

2+d|Rows: 2
|===

Cypher has other mathematical operators that allow for other types of numerical comparison.
See link:https://neo4j.com/docs/cypher-manual/current/expressions/mathematical-operators/[Cypher -> Mathematical operators] for the complete list of operators and examples.

=== Boolean

Cypher's boolean operators allow you to combine or evaluate logical conditions.

For example, to find who in the graph has directed a movie but didn't act in it:

[source,cypher]
--
MATCH (p:Person)-[:DIRECTED]->(m)
WHERE NOT (p)-[:ACTED_IN]->()
RETURN p, m
--

The result is:

image::robert-forrest.svg[Nodes for Robert Zemeckis and Forrest Gump, width=250, role=popup]

This is because the query looks for `Person` nodes that are connected to `Movie` nodes through the `DIRECTED` relationship *only* and *not* `ACTED_IN`.
If the `ACTED_IN` relationship wasn't a restriction anymore:

[source, cypher]
--
MATCH (p:Person)-[:DIRECTED]->(m)
RETURN p, m
--

Then the result includes Tom Hanks and the movie "Larry Crowne" because Tom Hanks *both* directed *and* acted in the movie:

image::tomrobert-movies.svg[Tom Hanks and Robert Zemeckis's nodes and the Forrest Gump and Larry Crowne movie nodes, width=450, role=popup]

See link:https://neo4j.com/docs/cypher-manual/current/expressions/predicates/boolean-operators/[Cypher -> Boolean operators] for the complete list of operators and examples.

== Range of values

You can query data within a certain range in number or date, for example, if you want to find events within a certain timeline, age values, etc.

image::workplace-graph.svg[Graph including people connected with each other through is friends with relationships, connected to company nodes through works at relationships, and connected to technology nodes with likes relationships, width=800, role=popup]

If you want to know who has experience within the range of three to seven years:

[source, cypher]
--
MATCH (p:Person)
WHERE 3 <= p.yearsExperience <= 7
RETURN p
--

The result is:

image::cypher-filter-ranges-arr.svg[width=400, role="popup-link"]

== Aliasing results

By default, Cypher returns a label as the name of the column in the tabular results.
However, you can use an alias to make the results more understandable by using `AS`.

For example, if you want to have the tabular result with a column titled `name` instead of the label `p.name`:

[source, cypher]
--
MATCH (p:Person)
RETURN p.name AS name
--

The result is:

[role="queryresult",options="header,footer",cols="1*<m"]
|===
| name

| "Keanu Reeves" | "Robert Zemeckis" | "Tom Hanks"
| "Diana" | "Melissa" | "Dan"
| "Sally" | "John" | "Jennifer"
| "Joe" | "Mark" | "Ann"

1+d|Rows: 12
|===

== Avoiding duplication

For example, to know which people are connected through a `IS_FRIENDS_WITH` relationship with each other:

[source, cypher]
--
MATCH (p:Person)-[:IS_FRIENDS_WITH]-(friend:Person)
RETURN friend.name;
--

The result is:

[role="queryresult",options="header,footer",cols="1*<m"]
|===
| friend.name

| "Joe"
| "Jennifer"
| "Ann"
| "John"
| "Jennifer"
| "Sally"
| "Jennifer"
| "Melissa"
| "Sally"
| "John"
| "Mark"
| "Ann"
| "Diana"
| "Mark"
| "Jennifer"
| "Joe"
| "Dan"
| "Jennifer"

1+d|Rows: 18
|===

Note that all names appear more than one time.
For example, "Sally" appears twice because she is connected to two people through two `IS_FRIENDS_WITH` relationships.
To avoid this, add `DISTINCT` after `RETURN`:

[source, cypher]
--
MATCH (p:Person)-[:IS_FRIENDS_WITH]->(friend:Person)
RETURN DISTINCT friend.name;
--

The result is now:

[role="queryresult",options="header,footer",cols="1*<m"]
|===
| friend.name

| "Sally"
| "Melissa"
| "John"
| "Mark"
| "Ann"
| "Diana"
| "Dan"

1+d|Rows: 7
|===

== Order

If you want to have the results ordered, you can use the clause link:https://neo4j.com/docs/cypher-manual/current/clauses/order-by/[`ORDER BY`] after the `RETURN` clause.
For example, to list how many years of experience each person has in descending order:

[source, cypher]
--
MATCH (p:Person)
RETURN p.yearsExperience AS yearsExperience
ORDER BY yearsExperience DESC
--

Optionally, you can also use `WITH` together with `ORDER BY`:

[source, cypher]
--
MATCH (p:Person)
WITH p
ORDER BY p.yearsExperience DESC
RETURN p.yearsExperience AS yearsExperience
--

This is the result:

[role="queryresult",options="header,footer",cols="1*<m"]
|===

| yearsExperience

| null | null | null | null | null | null | null | null
| 6 | 5 | 5 | 4

1+d|Rows: 12
|===

Note that the first 8 rows contain `null` as result.
This means the property `yearsExperience` doesn't exist to all `Person` nodes, but existing entries are ordered in descending order, as stated in the query.

Optionally, you can avoid returning `null` values by using `WHERE` and `IS NOT NULL`:

[source, cypher]
--
MATCH (p:Person)
WHERE p.yearsExperience IS NOT NULL
RETURN p.yearsExperience AS yearsExperience
ORDER BY yearsExperience DESC
--

== Limit

You can use `LIMIT` when you want to restrict the number of results returned.
For example, the current example graph has twelve `Person` nodes and if you want to retrieve only three:

[source, cypher]
--
MATCH (p:Person)
RETURN p
LIMIT 3
--

The result is:

[role="queryresult",options="header,footer",cols="1*<m"]
|===

| p

| (:Person {born: 1964, name: "Keanu Reeves"})
| (:Person {born: 1951, name: "Robert Zemeckis"})
| (:Person {born: 1956, name: "Tom Hanks"})

1+d|Rows: 3
|===

Since you didn't use xref:cypher/results.adoc#_order[`ORDER BY`] to specify an order to the results, the query retrieves the first three `Person` nodes that were added to the graph.
To get random results, you can add `ORDER BY rand()` to the query:

[source, cypher]
--
MATCH (p:Person)
RETURN p
ORDER BY rand()
LIMIT 3
--

Now every time you run this query, you get three different `Person` nodes.

== Aggregate

Cypher provides several link:https://neo4j.com/docs/cypher-manual/current/functions/aggregating/[aggregating functions].
You can use them with the `RETURN` or the `WITH` clauses to aggregate results.

[options=header,cols="1,4"]
|===

| Function | Description

| link:https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-avg[`avg()`]
| Returns the average of a set of `INTEGER`, `FLOAT` or `DURATION` values.

| link:https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-collect[`collect()`]
| Returns a list containing the values returned by an expression.

| link:https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-count[`count()`]
| Returns the number of values or rows.

| link:https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-max[`max()`]
| Returns the maximum value in a set of values.

| link:https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-min[`min()`]
| Returns the minimum value in a set of values.

| link:https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-percentilecont[`percentileCont()`]
| Returns the percentile of a value over a group using linear interpolation.

| link:https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-percentiledisc[`percentileDisc()`]
| Returns the nearest `INTEGER` or `FLOAT` value to the given percentile over a group using a rounding method.

| link:https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-stdev[`stDev()`]
| Returns the standard deviation for the given value over a group for a sample of a population.

| link:https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-stdevp[`stDevP()`]
| Returns the standard deviation for the given value over a group for an entire population.

| link:https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-sum[`sum()`]
| Returns the sum of a set of INTEGER, FLOAT or DURATION values.

|===

Refer to link:https://neo4j.com/docs/cypher-manual/current/functions/aggregating/[Cypher -> Aggregating] for the complete list of all aggregating functions and examples.

== Unwind

If you have a list that you want to inspect or separate the values, Cypher offers the link:https://neo4j.com/docs/cypher-manual/current/clauses/unwind/[`UNWIND`] clause for that.
It does the opposite of link:https://neo4j.com/docs/cypher-manual/current/functions/aggregating/#functions-collect[`collect()`] and separates a list into individual values on separate rows.

For example, if you want to see which people in the example graph like "Graphs" and/or "Query Languages":

[source, cypher]
--
WITH ['Graphs','Query Languages'] AS likedTech
UNWIND likedTech AS technology
MATCH (p:Person)-[r:LIKES]-(t:Technology {type: technology})
RETURN t.type, collect(p.name) AS people;
--

Note that `UNWIND` is combined with link:https://neo4j.com/docs/cypher-manual/current/clauses/with/[`WITH`] and used *before* the `MATCH` clause.
This is because Cypher executes queries from top to bottom, row by row.

If you add `UNWIND` before `MATCH`, it controls what gets matched.
After `MATCH`, it becomes a filter and the query would need to be written differently too.

[source,cypher]
--
MATCH (p:Person)-[:LIKES]-(t:Technology)
WITH p, t, ['Graphs','Query Languages'] AS likedTech
UNWIND likedTech AS technology
WITH p, t
WHERE t.type = technology
RETURN t.type, collect(DISTINCT p.name) AS people
--

The result of this query is:

[role="queryresult",options="header,footer",cols="2*<m"]
|===

| t.type | people

| "Graphs"
| ["Diana", "Melissa", "Jennifer", "Mark"]

| "Query Languages"
| ["Diana", "Melissa", "Joe"]

2+d|Rows: 2
|===

== Number of items

If you have a list of elements, you can also return the number of elements in that list using the link:https://neo4j.com/docs/cypher-manual/current/functions/scalar/#functions-size[`size()`] function.

For example, if you want to know how many friends each person in the graph has:

[source, cypher]
--
MATCH (p:Person)-[:IS_FRIENDS_WITH]-(friend:Person)
RETURN p.name, size(collect(friend.name)) AS numberOfFriends;
--

The result is:

[role="queryresult",options="header,footer",cols="2*<m"]
|===

| p.name | numberOfFriends

| "Diana"
| 1

| "Melissa"
| 1

| "Dan"
| 1

| "Sally"
| 2

| "John"
| 2

| "Jennifer"
| 5

| "Joe"
| 2

| "Mark"
| 2

| "Ann"
| 1

2+d|Rows: 9
|===

Note that if you add a direction to the relationship:

[source, cypher]
--
MATCH (p:Person)-[:IS_FRIENDS_WITH]->(friend:Person)
RETURN p.name, size(collect(friend.name)) AS numberOfFriends;
--

You get a different result:

[role="queryresult",options="header,footer",cols="2*<m"]
|===

| p.name | numberOfFriends

| "John"
| 1

| "Jennifer"
| 5

| "Joe"
| 2

| "Ann"
| 1

2+d|Rows:4
|===

This is because some `Person` nodes are only connected to other `Person` nodes through a specific direction of the `IS_FRIENDS_WITH` relationship.

For example, Jennifer is connected to Mark through an outgoing `IS_FRIENDS_WITH` relationship from Jennifer to Mark (i.e. `(jennifer)-[:IS_FRIENDS_WITH]->(mark)`), not `(mark)-[:IS_FRIENDS_WITH]->(jennifer)`.

In practice, the fact that Jennifer and Mark are friends is what matters, so the relationship's direction is irrelevant.
However, when adding this information to the graph, the relationship xref:cypher/index.adoc#_relationship_directions[must have a direction].
On the other hand, querying for it doesn't require direction.

Creating a new pattern with the opposite direction (i.e. `(mark)-[:IS_FRIENDS_WITH]->(jennifer)`) wouldn't be incorrect from a syntax perspective, but it's duplicate information when the direction is irrelevant to answer the question "who is friends with whom?".
This is why a more accurate result is achieved by using a query with an undirected relationship.

== Composed queries

There are different ways to combine separate query branches within a single query:

[options=header,cols="1,4"]
|===

| Function | Description

| link:https://neo4j.com/docs/cypher-manual/current/queries/composed-queries/combined-queries/[`UNION`]
| Combines the results of two or more queries into a single result set that includes all the rows that belong to any queries in the union.

| link:https://neo4j.com/docs/cypher-manual/current/queries/composed-queries/conditional-queries/[`WHEN`] 
| Together with `THEN` and `ELSE`, it enables different branches of a query to execute based on certain conditions. label:cypher[Cypher 25 only]

| link:https://neo4j.com/docs/cypher-manual/current/queries/composed-queries/sequential-queries/[`NEXT`]
| Allows for linear composition of queries into a sequence of smaller, self-contained segments, passing the whole table of intermediate results from one segment to the next. label:cypher[Cypher 25 only]

|===

For examples on how to use these clauses, refer to link:https://neo4j.com/docs/cypher-manual/current/queries/composed-queries/[Cypher -> Composed queries].

== Keep learning

Cypher has many other resources for getting more accurate results.
If you want to keep learning, see the following pages:

. link:https://neo4j.com/docs/cypher-manual/current/clauses/skip/[`SKIP`] -> Defines from which row to start including the rows in the output.
. link:https://neo4j.com/docs/cypher-manual/current/expressions//[Expressions] -> Operators and expressions that can be used to evaluate values.
. link:https://neo4j.com/docs/cypher-manual/current/functions/[Functions] -> Full list of existing Cypher functions.
. link:https://neo4j.com/docs/cypher-manual/current/indexes/[Indexes] -> Strategies for speeding up data retrieval.
