[[cypher-intro]]
= What is Cypher
:description: A high-level overview of the graph query language Cypher.
:page-ad-overline-link: https://graphacademy.neo4j.com/courses/cypher-fundamentals
:page-ad-overline: Neo4j GraphAcademy
:page-ad-title: Cypher Fundamentals
:page-ad-description: Learn Cypher in this free, hands-on course
:page-ad-link: https://graphacademy.neo4j.com/courses/cypher-fundamentals
:page-ad-underline-role: button
:page-ad-underline: Learn more

[IMPORTANT]
====
This page covers the basics of Cypher.
For the complete documentation, refer to link:{docs-home}/cypher/[Cypher].
====

.A visual representation of a Cypher query
image::cypher-learning-arr.svg[role="popup-link",width=450]

Cypher is Neo4j's declarative query language. 
Available as open source via link:http://openCypher.org[The openCypher project], Cypher is link:{docs-home}/cypher-manual/current/introduction/cypher-overview/#_cypher_and_sql_key_differences[similar to SQL], but optimized for graphs.
This means Cypher focuses on *what data* you want out of the graph rather than *how to* get it.

Intuitive and close to natural language, Cypher provides a visual way of matching patterns and relationships by having its own design based on ASCII-art type of syntax:

[source,cypher]
----
(nodes)-[:ARE_CONNECTED_TO]->(otherNodes)
----

Round brackets are used to represent `(nodes)`, and `-[:ARROWS]->` to represent a relationship between the `(nodes)`.
With this query syntax, you can perform create, read, update, or delete (CRUD) operations on your graph.

[TIP]
====
For a quick look with no installation required, get a free link:https://neo4j.com/cloud/platform/aura-graph-database/[Aura instance].
Write `:guide cypher` in Aura's "Query" tab to access a hands-on guide on Cypher.
====

== How does Cypher work?

Neo4j's graph model is composed of <<nodes>> and <<relationships>>, which may also have <<properties>> associated with them.
With nodes and relationships, you can build powerful patterns that can express simple or complex traversals and paths.

Pattern recognition is a fundamental human cognitive process, and that is why visual diagrams or memory-matching games can be useful in learning.
Cypher is also heavily based on patterns and it is designed to recognize them in data.
That makes Cypher a language that is easy to learn and use.

[#cypher-syntax]
== Cypher syntax

ifndef::backend-pdf[]
++++
<div class="responsive-embed">
<iframe width="560" height="315" src="https://www.youtube.com/embed/_dup3YOZSm8" title="What is Cypher?" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>
++++
endif::[]

ifdef::backend-pdf[]
link:https://www.youtube.com/watch?v=_dup3YOZSm8[What is Cypher?]
endif::[]

Cypher's constructs are based on English prose and iconography.
This makes queries easy both to write and to read.

.A graph example involving four nodes and three relationships.
image::cypherintro-graph1.svg[role="popup-link",width=600]

If you were to represent the data in this graph in English, it might read as something like: _"Sally likes Graphs. Sally is friends with John. Sally works for Neo4j."_

Now, if you were to write this same information in Cypher, then it would look like this:

[source, cypher]
----
(Sally)-[:LIKES]->(Graphs)
(Sally)-[:IS_FRIENDS_WITH]->(John)
(Sally)-[:WORKS_FOR]->(Neo4j)
----

However, in order to have this information in the graph, first you need to represent it as nodes and relationships.

=== Nodes

In a property graph model, the main components are nodes and relationships.
Nodes are often used to represent nouns or objects in your data model.
In the previous example, `Sally`, `John`, `Graphs`, and `Neo4j` are the nodes:

.A visual representation of nodes.
image::cypherintro-nodes.svg[role="popup-link",width=450]

In Cypher, you can depict a node by surrounding it with parentheses, e.g. `(node)`.
The parentheses are a representation of the circles that compose the nodes in the visualization.

==== Node labels

Nodes can be grouped together through a <<label>>.
They work like tags and allow you to specify certain types of entities to look for or to create.
Labels also help Cypher distinguish between entities and optimize execution for your queries.

In the example, both `Sally` and `John` can be grouped under a `Person` label, `Graphs` can receive a `Technology` label, and `Neo4j` can be labeled as `Company`:

.Nodes grouped in labels. Note that `Sally`, `John`, `Graphs`, and `Neo4j` are now xref:cypher.adoc#cypher-properties[properties] instead.
image::cypher-graph-nodes-arr.svg[role="popup-link",width=450]

In a relational database context, this would be the same as telling SQL which table to look for the particular row.
The same way you can tell SQL to query a person's information from a `Person` table, you can also tell Cypher to only check the `Person` label for that information.

[CAUTION]
====
If you do not specify a label for Cypher to filter out non-matching node categories, the query will check all of the nodes in the database.
This can affect performance in very large graphs.
====

==== Node variables

You don't need to refer to a label always in full.
Similarly to abbreviations and other programming language variables, node variables can be used as a shortcut.

In this example, you can use the variable `(p)`, for example, to replace `Person`, so you don't need to write it in full every time you mention it in the same query:

[source,cypher]
----
(p:Person)         //using variable p and label Person
----

If the node is not relevant to your return results, you can also specify an anonymous node using empty parentheses `()`.
However, you can't return anonymous nodes later in the query.

[source,cypher]
----
()                //anonymous node (no label or variable) can refer to any node in the database
----

You can also refrain from using a variable for certain nodes:

[source,cypher]
----
(:Technology)     //no variable, label Technology
----

Or use a whole word as the variable:

[source,cypher]
----
(work:Company)   //using variable work and label Company
----

[#cypher-relationships]
=== Relationships

One of the benefits of graph databases is that you can store information about how elements are related to each other in the form of relationships between the elements (nodes).
In Cypher, relationships are represented as an arrow connecting two nodes (e.g. `(Node1)-->(Node2)`), similarly to how you would represent that if drafting on a whiteboard.

In the example, the lines containing `:LIKES`, `:IS_FRIENDS_WITH`, and `:WORKS_FOR` represent the relationship between the nodes:

.Graph featuring nodes and relationships.
image::cypherintro-graph1.svg[]

==== Relationship directions

Relationships *must* always have a direction and a colon (`:`) in the beginning of it.
They can go from left to right:

[source,cypher]
----
(p:Person)-[:LIKES]->(t:Technology)
----

From right to left:

[source,cypher]
----
(p:Person)<-[:LIKES]-(t:Technology)
----

Or be undirected (where the direction is *not* specified):

[source,cypher]
----
(p:Person)-[:LIKES]-(t:Technology)
----

An undirected relationship does not mean that it doesn't have a direction, but that it can be traversed in *either* direction.

When using undirected relationships in a query, Cypher retrieves *all* nodes connected by the specified relationship type, regardless of direction.
This allows for flexible querying. 

Undirected relationships are particularly useful in this case, because if you write a query with the wrong direction, Cypher will not return anything.
For this reason, it is recommended to use an undirected relationship instead, so you can get any results back.

==== Relationship types

In the previous section, you saw how nodes can be connected through a relationship, but the only information that you had there is the direction of this connection.

Relationship types categorize and add meaning to a relationship, similar to how labels group nodes together.
It is considered best practice to use verbs or derivatives for the relationship type.
The type describes how the nodes relate to each other.
This way, Cypher is almost like natural language, where nodes are the subjects and objects (nouns), and the relationships (verbs) are the action words that relate them.

In the example used in this page, the relationship types are:

* `[:LIKES]` - communicates that Sally (a node) _likes_ graphs (another node).
* `[:IS_FRIENDS_WITH]` - communicates that Sally _is friends with_ John.
* `[:WORKS_FOR]` - communicates that Sally _works for_ Neo4j.

==== Relationship variables

In the same way as xref:cypher.adoc#_node_variables [node variables], relationship variables can also be used as a shortcut.
Instead of writing the whole relationship type name (e.g. `[:LIKES]`) twice in the query, you can use a variable.

Take this example:

[source,cypher]
----
MATCH (p:Person)-[r:LIKES]->(t:Technology)
RETURN p,r,t
----

This query has variables for both the nodes with the labels `Person` and `Technology`, and the relationship `:LIKES`.
In the return clause, you can then use the variables (i.e.`p`, `r`, and `t`) instead of spelling out the full node labels and relationship type.

This would be your result:

.Result for the example query using node and relationship variables.
image::cypherintro-variables.svg[]

.Result
[role="queryresult",options="header,footer",cols="3*<m"]
|===
| p | r | t

| (:Person) | [:LIKES]  | (:Technology)

3+d|Rows: 1
|===

Remember to always use a colon in front of a relationship type.
If you happen to forget it, and write the query like this:

[source,cypher]
----
(Person)-[LIKES]->(Technology)
----

`[LIKES]` will represent a relationship *variable*, not a relationship *type*.
In this case, since no relationship type is declared, Cypher will search for all types of relationships in order to retrieve a result to your query.

[#cypher-properties]
=== Properties

Properties are name-value pairs that provide additional details to nodes and relationships.
In Cypher, they are represented by curly brackets within the parentheses of a node or the brackets of a relationship:

.Graph example with node and relationship properties.
image::cypherintro-properties.svg[]

[source,cypher]
----
(Person {name: 'Sally'})-[:IS_FRIENDS_WITH {since:'2018'}]->(Person {name: 'John'})
----

Properties can have values with a variety of data types.
You can see the full list of values and types in the link:https://neo4j.com/docs/cypher-manual/current/values-and-types/[Cypher documentation].

[#cypher-patterns]
=== Patterns in Cypher

As mentioned before, Cypher is heavily based on patterns and it is designed to recognize them in data.
For example:

[source, cypher]
----
(p:Person {name: "Sally"})-[rel:LIKES]->(g:Technology {type: "Graphs"})
----

This bit of Cypher represents a pattern, but it is not a query.
It only expresses that `Person` node with _Sally_ as its `name` property has a `:LIKES` relationship with the `Technology` node with _Graphs_ as its `type` property.

In order to *do* something with this pattern, for example, adding it to the graph or retrieving it in case it already exists, you need to *query* the database.

== Keep learning

Now that the basic Cypher concepts have been introduced, you can follow the tutorial on how to xref:tutorials/cypher-basics.adoc[Get started with Cypher] for a more hands-on approach.
In the complete link:{docs-home}/cypher-manual[Cypher manual], you will also find more information on:

* How to write link:{docs-home}/cypher-manual/current/queries/basic/[basic queries] and what link:{docs-home}/cypher-manual/current/clauses/[clauses] you can use to read data from the database.
* How link:{docs-home}/cypher-manual/current/patterns/[patterns] work and how you can use them to navigate, describe and extract data from a graph.
* What link:{docs-home}/cypher-manual/current/values-and-types/[values and types], and link:{docs-home}/cypher-manual/current/functions/[functions] are available in Cypher.

=== From SQL to Cypher

In case you have a background in SQL and are new to graph databases, these are some resources for more information on the key differences and the transition to graphs:

* link:{docs-home}/cypher-manual/current/introduction/cypher-overview/#_cypher_and_sql_key_differences[Key differences between Cypher and SQL]
* xref:reference/graphdb-vs-rdbms[Transition from relational to graph database]
* xref:tutorials/cypher-sql.adoc[Tutorial: Comparing Cypher with SQL]
* xref:how-to/relational-to-graph-import.adoc[How-to: Import from RDBMS into graph]
* xref:tutorials/import-relational-and-etl.adoc[Tutorial: Import data from a relational database into Neo4j]
* link:how-to/relational-to-graph-modeling.adoc[How-to: Model data from relational to graph]

=== From NoSQL to Graphs

If you are familiar with NoSQL ("Not only SQL") system, you can also learn more on xref:reference/graphdb-concepts/graphdb-vs-nosql.adoc[how to make the transition] to a graph database.

=== GraphAcademy

With the link:https://graphacademy.neo4j.com/courses/cypher-fundamentals/[Cypher Fundamentals] course, you can learn Cypher in 60 minutes and practice using a sandbox.

=== Other resources

For more suggestions on how to expand your knowledge about Cypher, refer to xref:reference/resources.adoc[Resources].

ifndef::backend-pdf[]
[discrete.glossary]
endif::[]
== Glossary

include::glossary.adoc[]

ifdef::backend-pdf[]
<<<
endif::[]