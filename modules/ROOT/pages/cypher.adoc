[[cypher-intro]]
= What is Cypher
:description: A high-level overview of the graph query language Cypher.
:page-ad-overline-link: https://graphacademy.neo4j.com/courses/cypher-fundamentals
:page-ad-overline: Neo4j GraphAcademy
:page-ad-title: Cypher Fundamentals
:page-ad-description: Learn Cypher in this free, hands-on course
:page-ad-link: https://graphacademy.neo4j.com/courses/cypher-fundamentals
:page-ad-underline-role: button
:page-ad-underline: Learn more

[IMPORTANT]
====
This page covers the basics of Cypher.
For the complete documentation, refer to link:{docs-home}/cypher/[Cypher].
====

.A visual representation of a Cypher query
image::cypher-learning-arr.svg[role="popup-link",width=450]

Cypher is Neo4j's declarative query language. 
Available as open source via link:http://openCypher.org[The openCypher project], Cypher is link:{docs-home}/cypher-manual/current/introduction/cypher-overview/#_cypher_and_sql_key_differences[similar to SQL], but optimized for graphs.
This means Cypher focuses on *what data* you want out of the graph rather than *how to* get it.

Intuitive and close to natural language, Cypher provides a visual way of matching patterns and relationships by having its own design based on ASCII-art type of syntax:

[source,cypher]
----
(nodes)-[:ARE_CONNECTED_TO]->(otherNodes)
----

Round brackets are used to represent `(nodes)`, and `-[:ARROWS]->` to represent a relationship between the `(nodes)`.
With this query syntax, you can perform create, read, update, or delete (CRUD) operations on your graph.

[TIP]
====
For a quick look with no installation required, get a free link:https://neo4j.com/cloud/platform/aura-graph-database/[Aura instance].
Open *Query* and write `:guide cypher` to access a hands-on guide on Cypher.
====

== How does Cypher work?

Neo4j's graph model is composed of <<nodes>> and <<relationships>>, which may also have <<properties>> associated with them.
With nodes and relationships, you can build powerful patterns that can express simple or complex traversals and paths.

Pattern recognition is a fundamental human cognitive process, and that is why visual diagrams or memory-matching games can be useful in learning.
Cypher is also heavily based on patterns and it is designed to recognize them in data.
That makes Cypher a language that is easy to learn and use.

[#cypher-syntax]
== Cypher syntax

ifndef::backend-pdf[]
++++
<div class="responsive-embed">
<iframe width="560" height="315" src="https://www.youtube.com/embed/_dup3YOZSm8" title="What is Cypher?" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>
++++
endif::[]

ifdef::backend-pdf[]
link:https://www.youtube.com/watch?v=_dup3YOZSm8[What is Cypher?]
endif::[]

Cypher's constructs are based on English prose and iconography.
This makes queries easy both to write and to read.

.A graph example involving four nodes and three relationships.
image::cypherintro-graph1.svg[role="popup-link",width=600]

If you were to represent the data in this graph in English, it might read as something like: _"Sally likes Graphs. Sally is friends with John. Sally works for Neo4j."_

Now, if you were to write this same information in Cypher, then it would look like this:

[source, cypher]
----
(Sally)-[:LIKES]->(Graphs)
(Sally)-[:IS_FRIENDS_WITH]->(John)
(Sally)-[:WORKS_FOR]->(Neo4j)
----

However, in order to have this information in the graph, first you need to represent it as nodes and relationships.

=== Nodes

In a property graph model, the main components are nodes and relationships.
Nodes are often used to represent nouns or objects in your data model.
In the previous example, `Sally`, `John`, `Graphs`, and `Neo4j` are the nodes:

.A visual representation of nodes.
image::cypherintro-nodes.svg[role="popup-link",width=450]

In Cypher, you can depict a node by surrounding it with parentheses, e.g. `(node)`.
The parentheses are a representation of the circles that compose the nodes in the visualization.

==== Node labels

Nodes can be grouped together through a <<label>>.
They work like tags and allow you to specify certain types of entities to look for or to create.
Labels also help Cypher distinguish between entities and optimize execution for your queries.

In the example, both `Sally` and `John` can be grouped under a `Person` label, `Graphs` can receive a `Technology` label, and `Neo4j` can be labeled as `Company`:

.Nodes grouped in labels. Note that `Sally`, `John`, `Graphs`, and `Neo4j` are now xref:cypher.adoc#cypher-properties[properties] instead.
image::cypher-graph-nodes-arr.svg[role="popup-link",width=450]

In a relational database context, this would be the same as telling SQL which table to look for the particular row.
The same way you can tell SQL to query a person's information from a `Person` table, you can also tell Cypher to only check the `Person` label for that information.

[CAUTION]
====
If you do not specify a label for Cypher to filter out non-matching node categories, the query will check all of the nodes in the database.
This can affect performance in very large graphs.
====

==== Node variables

You don't always need to refer to a label in full.
Similarly to abbreviations and other programming language variables, node variables can be used as a shortcut.

In this example, you can use the variable `(p)`, for example, to replace `Person`, so you don't need to write it in full every time you mention it in the same query:

[source,cypher]
----
(p:Person)         //using variable p and label Person
----

If the node is not relevant to your return results, you can also specify an anonymous node using empty parentheses `()`.
However, you can't return anonymous nodes later in the query.

[source,cypher]
----
()                //anonymous node (no label or variable) can refer to any node in the database
----

You can also refrain from using a variable for certain nodes:

[source,cypher]
----
(:Technology)     //no variable, label Technology
----

Or use a whole word as the variable:

[source,cypher]
----
(work:Company)   //using variable work and label Company
----

[#cypher-relationships]
=== Relationships

One of the benefits of graph databases is that you can store information about how elements are related to each other in the form of relationships between the elements (nodes).

In Cypher, relationships are represented as square brackets and an arrow connecting two nodes (e.g. `(Node1)-[]->(Node2)`), as how you may draw a relationship on a whiteboard.

In the example, the lines containing `:LIKES`, `:IS_FRIENDS_WITH`, and `:WORKS_FOR` represent the relationship between the nodes:

.Graph featuring nodes and relationships.
image::cypherintro-graph1.svg[]

[NOTE]
====
Best practice is to write the relationship type in upper-case, preceded by a colon (`:`).
====

==== Relationship directions

Relationships *always* have a direction which is indicated by an arrow.

They can go from left to right:

[source,cypher]
----
(p:Person)-[:LIKES]->(t:Technology)
----

From right to left:

[source,cypher]
----
(p:Person)<-[:LIKES]-(t:Technology)
----

Or be undirected (where the direction is *not* specified):

[source,cypher]
----
MATCH (p:Person)-[:LIKES]-(t:Technology)
----

==== Undirected relationships

An undirected relationship does not mean that it doesn't have a direction, but that it can be traversed in *either* direction.
While you can't *create* relationships without a direction, you can *query* them undirected (in the example, using the link:{docs-home}/cypher-manual/current/clauses/match/[`MATCH`] clause).

Using undirected relationships in queries is particularly useful when you don't know the direction, since Cypher won't return anything if you write a query with the wrong direction.
Cypher will therefore retrieve *all* nodes connected by the specified relationship type, regardless of direction.

[CAUTION]
====
Due to performance reasons, it is generally not recommended to query undirected relationships, especially in the case of larger datasets.
====

==== Relationship types

Relationship types categorize and add meaning to a relationship, similar to how labels group nodes together.
It is considered best practice to use verbs or derivatives for the relationship type.
The type describes how the nodes relate to each other.
This way, Cypher is almost like natural language, where nodes are the subjects and objects (nouns), and the relationships (verbs) are the action words that relate them.

In the previous example, the relationship types are:

* `[:LIKES]` - communicates that Sally (a node) _likes_ graphs (another node).
* `[:IS_FRIENDS_WITH]` - communicates that Sally _is friends with_ John.
* `[:WORKS_FOR]` - communicates that Sally _works for_ Neo4j.

==== Relationship variables

Variables can be used for relationships in the same way as for nodes. 
Once you specify a variable, you can use it later in the query to reference the relationship.

Take this example:

[source,cypher]
----
MATCH (p:Person)-[r:LIKES]->(t:Technology)
RETURN p,r,t
----

This query specifies variables for both the node labels (`p` for `Person` and `t` for `Technology`) and the relationship type (`r` for `:LIKES`).
In the return clause, you can then use the variables (i.e.`p`, `r`, and `t`) instead of spelling out the full node labels and relationship type.

This would be your result:

.Result for the example query using node and relationship variables.
image::cypherintro-variables.svg[]

.Result
[role="queryresult",options="header,footer",cols="3*<m"]
|===
| p | r | t

| (:Person) | [:LIKES]  | (:Technology)

3+d|Rows: 1
|===

Remember to always put a colon in front of a relationship type.
If you happen to forget it, and write the query like this:

[source,cypher]
----
(Person)-[LIKES]->(Technology)
----

`[LIKES]` will represent a relationship *variable*, not a relationship *type*.
In this case, since no relationship type is declared, Cypher will search for all types of relationships in order to retrieve a result to your query.

[#cypher-properties]
=== Properties

Property values can be added both to nodes and relationships.
They can also be of a variety of data types.
For a full list of values and types, see link:{docs-home}cypher-manual/current/values-and-types/[Cypher manual -> Values and types].

Another way to organize the data in the previous example would be to add a *property*, `name`, and `Sally` and `John` as *property values* on `Person`-labeled nodes:

.Graph example with node and relationship properties.
image::cypherintro-properties.svg[]

[source,cypher]
----
CREATE (Person {name:'Sally'})-[:IS_FRIENDS_WITH]->(Person {name:'John'})
RETURN p,r
----

Note that properties are enclosed by curly brackets (`{}`), and with its content enclosed by apostrophes (`''`).

In case you have already added Sally and John as node labels, but want to change them into node properties, you need to refactor your graph.
Refactoring is a strategy in link:{docs-home}/model[data modeling] that you can learn more about in link:{docs-home}/getting-started/data-modeling/graph-model-refactoring/[this tutorial].

[#cypher-patterns]
=== Patterns in Cypher

As mentioned before, Cypher is heavily based on patterns and it is designed to recognize them in data.
For example:

[source, cypher]
----
(p:Person {name: "Sally"})-[rel:LIKES]->(g:Technology {type: "Graphs"})
----

This bit of Cypher represents a pattern, but it is not a query.
It only expresses that `Person` node with _Sally_ as its `name` property has a `:LIKES` relationship with the `Technology` node with _Graphs_ as its `type` property.

In order to *do* something with this pattern, such as adding it to or retrieving it from the graph, you need to *query* the database.

For example, you can add information to the database:

[source, cypher]
----
CREATE (p:Person {name: "Sally"})-[r:LIKES]->(t:Technology {type: "Graphs"})
----

And once this data is written to the database, you can retrieve it with this pattern:

[source, cypher]
----
MATCH (p:Person {name: "Sally"})-[r:LIKES]->(t:Technology {type: "Graphs"})
RETURN p,r,t
----

== Keep learning

Now that the basic Cypher concepts have been introduced, you can take the tutorial on how to xref:tutorials/cypher-basics.adoc[Get started with Cypher] to learn how to write your own queries.
In the link:{docs-home}/cypher-manual[Cypher manual], you can find more information on:

* How to write link:{docs-home}/cypher-manual/current/queries/basic/[basic queries] and what link:{docs-home}/cypher-manual/current/clauses/[clauses] you can use to read data from the database.
* How link:{docs-home}/cypher-manual/current/patterns/[patterns] work and how you can use them to navigate, describe and extract data from a graph.
* What link:{docs-home}/cypher-manual/current/values-and-types/[values and types], and link:{docs-home}/cypher-manual/current/functions/[functions] are available in Cypher.

=== From SQL to Cypher

In case you have a background in SQL and are new to graph databases, these are some resources for more information on the key differences and the transition to graphs:

* link:{docs-home}/cypher-manual/current/introduction/cypher-overview/#_cypher_and_sql_key_differences[Key differences between Cypher and SQL]
* xref:reference/graphdb-vs-rdbms[Transition from relational to graph database]
* xref:tutorials/cypher-sql.adoc[Tutorial: Comparing Cypher with SQL]
* xref:how-to/relational-to-graph-import.adoc[How-to: Import from RDBMS into graph]
* xref:tutorials/import-relational-and-etl.adoc[Tutorial: Import data from a relational database into Neo4j]
* link:how-to/relational-to-graph-modeling.adoc[How-to: Model data from relational to graph]

=== From NoSQL to Graphs

If you are familiar with NoSQL ("Not only SQL") system, you can also learn more on xref:reference/graphdb-concepts/graphdb-vs-nosql.adoc[how to make the transition] to a graph database.

=== GraphAcademy

With the link:https://graphacademy.neo4j.com/courses/cypher-fundamentals/[Cypher Fundamentals] course, you can learn Cypher in 60 minutes and practice using a sandbox.

=== Other resources

For more suggestions on how to expand your knowledge about Cypher, refer to xref:reference/resources.adoc[Resources].

ifndef::backend-pdf[]
[discrete.glossary]
endif::[]
== Glossary

include::glossary.adoc[]

ifdef::backend-pdf[]
<<<
endif::[]