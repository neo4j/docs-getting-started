[[graphdb-vs-rdbms]]
= Transition from relational to graph database
:description: This page explores the conceptual differences between relational and graph database structures and data models.

This page explores the conceptual differences between relational and graph database structures and data models.
For a comparison between programming languages, see xref:cypher-intro/cypher-sql.adoc[Comparing Cypher with SQL].

[#relational-vs-graph]
== Relational database overview

Relational databases store highly-structured data in tables with predetermined columns and rows of specific types of information.
Due to the rigidity of their organization, relational databases require developers and applications to strictly structure the data used in their applications.

In relational databases, references to other rows and tables are indicated by referring to primary key attributes via foreign key columns.
Joins are computed at query time by matching primary and foreign keys of all rows in the connected tables.
These operations are compute-heavy and memory-intensive, and have an exponential cost.

When many-to-many relationships occur in the model, you must introduce a `JOIN` table (or associative entity table) that holds foreign keys of both the participating tables, further increasing join operation costs, as shown in the image:

image::relational_model.svg[Depiction of a relational database with connecting points in each table,role=popup,width=600]

The diagram shows the concept of connecting an `Employee` (from the `Employee` table) to a `Department` (in the `Departments` table) by creating a `Dpt_Members` join table that contains the ID of the employee in one column and the ID of the associated department in another column.

This structure makes understanding the connections cumbersome, because you must know the employee and the department's ID values (performing additional lookups to find them) in order to know which employee connects to which department.

These types of costly join operations are often addressed by denormalizing the data to reduce the number of joins necessary, therefore breaking the data integrity of a relational database.
Graph databases stand where relational databases don't cover the needs of developers, and offer other ways to connect data.

[#relational-to-graph]
== Translating relational knowledge to graphs

Unlike other database management systems, relationships are of equal importance to the data itself in a graph.
This means you are not required to infer connections between entities using special properties such as foreign keys or out-of-band processing like map-reduce.

By assembling nodes and relationships into connected structures, graph databases enable building simple and sophisticated models that map closely to a problem domain.
Each node (entity or attribute) contains relationships to other nodes, and these relationship are organized by type and direction, holding or not additional attributes.

Whenever you would run xref:cypher-intro/cypher-sql.adoc[the equivalent of a `JOIN` operation], the graph database uses these relationships to directly access the connected nodes.
This eliminates the need for expensive search-and-match computations, and performance is altogether improved.

ifndef::backend-pdf[]
++++
<div class="responsive-embed">
<iframe width="640" height="360" src="https://www.youtube.com/embed/NO3C-CWykkY?start=294" frameborder="0" allowfullscreen></iframe>
</div>
++++
endif::[]

ifdef::backend-pdf[]
link:https://www.youtube.com/watch?v=NO3C-CWykkY[Video: https://www.youtube.com/watch?v=NO3C-CWykkY]
endif::[]

[#rdbms-graph-model]
== Data model differences

Graph data models have simpler and more expressive data models than those produced using relational or other NoSQL databases.
Take this example of a relational data model:

image::relational_as_graph.jpg[Relational data model connecting person and department tables,width=600,role=popup]

Here, the `Person` table has potentially millions of rows, one which has the entry "Alice", which is connected to the ID 815.
To know how she connects to the `Department` table, you need to locate all the rows that reference Alice's ID (815) and see in the `Department` table what are the actual values of the department IDs connected to Alice's ID (111, 119, 181).
Only then you know that Alice is part of the 4FUTURE, P0815, and A42 departments.

In a graph data model, however, there is one single node for Alice with the label `Person`.
Since she belongs to 3 different departments, each one of them is represented with a different node with the label `Department`:

image::relational-graph-model-arr.svg[Graph connecting the person node Alice to three different departments,role=popup,width=400]

To find which departments Alice belongs to, you would search the graph for Alice's node, then traverse all of the `BELONGS_TO` relationships from Alice to find the `Department` nodes she is connected to.
All this information is found on a single hop with no lookups involved.

[TIP]
====
To learn more about graph data modeling, refer to the xref:data-modeling/index.adoc[Model data section].
====

== Data storage and retrieval

Querying relational databases is easy with SQL - a declarative query language that allows both easy ad-hoc querying in a database tool, as well as use-case-specific querying from application code.
Even object-relational mappers (ORMs) use SQL under the hood to talk to the database.

Do graph databases have something similar?
Yes!

Cypher, Neo4j's declarative graph query language, is built on the basic concepts and clauses of SQL but has a lot of additional graph-specific functionality to make it easy to work with your graph model.

If you have ever tried to write a SQL statement with a large number of joins, you know that you quickly lose sight of what the query actually does because of all the technical noise in SQL syntax.
In Cypher, the syntax remains concise and focused on domain components and the connections among them, expressing the pattern to find or create data more visually and clearly.
Other clauses outside of the basic pattern matching look very similar to SQL, as Cypher was built on the predecessor language's foundations.

We will cover Cypher query language syntax in an upcoming guide, but let us look at a brief example of how a SQL query differs from a Cypher query.
In the organizational domain from our data modeling example above, what would a SQL statement that *lists the employees in the IT Department* look like, and how does it compare to the Cypher statement?

.SQL Statement
[source,sql]
----
SELECT name FROM Person
LEFT JOIN Person_Department
  ON Person.Id = Person_Department.PersonId
LEFT JOIN Department
  ON Department.Id = Person_Department.DepartmentId
WHERE Department.name = "IT Department"
----

.Cypher Statement
[source,cypher]
----
MATCH (p:Person)-[:WORKS_AT]->(d:Dept)
WHERE d.name = "IT Department"
RETURN p.name
----

[TIP]
====
You can find more about Cypher syntax in the upcoming chapters for https://neo4j.com/docs/getting-started/current/cypher-intro[Cypher Query Language^] and transitioning https://neo4j.com/developer/guide-sql-to-cypher/[from SQL to Cypher^].
====

[#rdbms-graph-practice]
=== Transitioning from Relational to Graph - In Practice

If you do decide to move your data from a relational to a graph database, the steps to transition your applications to use Neo4j are actually quite simple.
You can connect to Neo4j with a driver or connector library designed for your stack or programing language, just as you can with other databases.
Thanks to Neo4j and its community, there are Neo4j drivers that mimic existing database driver idioms and approaches for nearly any popular programing language.

For instance, the Neo4j JDBC driver would be used like this to query the database for _John's departments_:

[source, clike]
----
Connection con = DriverManager.getConnection("jdbc:neo4j://localhost:7474/");

String query =
    "MATCH (:Person {name:{1}})-[:EMPLOYEE]-(d:Department) RETURN d.name as dept";
try (PreparedStatement stmt = con.prepareStatement(QUERY)) {
    stmt.setString(1,"John");
    ResultSet rs = stmt.executeQuery();
    while(rs.next()) {
        String department = rs.getString("dept");
        ....
    }
}
----

[TIP]
====
For more information, you can visit our pages for https://neo4j.com/developer/language-guides/[Building Applications^] to see how to connect to Neo4j using different programming languages.
====

[#rdbms-graph-resources]
== Resources
* https://neo4j.com/resources/rdbms-developer-graph-white-paper/[Free eBook: Relational to Graph^]
* https://dzone.com/refcardz/from-relational-to-graph-a-developers-guide[DZone Refcard: From Relational to Graph^]
* https://neo4j.com/developer/data-modeling/[Data Modeling: Relational to Graph]
