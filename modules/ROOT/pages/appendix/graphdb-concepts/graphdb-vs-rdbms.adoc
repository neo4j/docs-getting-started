[[graphdb-vs-rdbms]]
= Comparing relational to graph database
:description: This page explores the conceptual differences between relational and graph database structures and data models.

This page explores the conceptual differences between relational and graph database structures and data models.
For a comparison between programming languages, see xref:cypher-intro/cypher-sql.adoc[Comparing Cypher with SQL].

[#relational-vs-graph]
== Relational database overview

Relational databases store highly-structured data in tables with predetermined columns and rows of specific types of information.
Due to the rigidity of their organization, relational databases require developers and applications to strictly structure the data used in their applications.

In relational databases, references to other rows and tables are indicated by referring to primary key attributes via foreign key columns.
Joins are computed at query time by matching primary and foreign keys of all rows in the connected tables.
These operations are compute-heavy and memory-intensive, and have an exponential cost.

When many-to-many relationships occur in the model, you must introduce a `JOIN` table (or associative entity table) that holds foreign keys of both the participating tables, further increasing join operation costs:

image::relational-model.svg[Depiction of a relational database with connecting points in each table,role=popup,width=400]

The diagram shows the concept of connecting an `Employee` (from the `Employee` table) to a `Department` (in the `Departments` table) by creating a `Dpt_Members` join table that contains the ID of the employee in one column and the ID of the associated department in another column.

This structure makes understanding the connections cumbersome, because you must know the employee and the department's ID values (performing additional lookups to find them) in order to know which employee connects to which department.

Additionally, these types of costly join operations are often addressed by denormalizing the data to reduce the number of joins necessary, therefore breaking the data integrity of a relational database.
Graph databases stand where relational databases don't cover the needs of developers, and offer other ways to connect data.

== Translating relational knowledge to graphs

Unlike other database management systems, relationships are of equal importance to the data itself in a graph data model.
This means you are not required to infer connections between entities using special properties such as foreign keys or out-of-band processing like map-reduce.

By assembling nodes and relationships into connected structures, graph databases enable building models that map closely to a problem domain.
Each node contains relationships to other nodes, and these relationship are organized by type and direction, holding or not additional attributes.

Whenever you run xref:cypher-intro/cypher-sql.adoc[the equivalent of a `JOIN` operation], the graph database uses these relationships, directly accessing the connected nodes and eliminating the need for expensive search-and-match computations.

This ability to pre-materialize relationships into the database structure allows Neo4j to provide performance of several orders of magnitude above others, especially for join-heavy queries, allowing users to leverage a _minutes to milliseconds_ advantage.

ifndef::backend-pdf[]
++++
<div class="responsive-embed">
<iframe width="640" height="360" src="https://www.youtube.com/embed/NO3C-CWykkY?start=294" frameborder="0" allowfullscreen></iframe>
</div>
++++
endif::[]

ifdef::backend-pdf[]
link:https://www.youtube.com/watch?v=NO3C-CWykkY[Video: https://www.youtube.com/watch?v=NO3C-CWykkY]
endif::[]

[#rdbms-graph-model]
== Data model differences

If you are familiar with the relational data model that has tables, columns, relationship cardinalities, and other components, graph data modeling will not seem entirely foreign.

The design of a xref:data-modeling/index.adoc[graph data model] still needs to be based upon requirements for access, queries, performance expectation, and business logic.
However, the structure is laid out differently.

For example, if you want to know which departments Alice belongs too, this is how a relational and a graph databases would structure the same data:

image::relational-as-graph.svg[Representation of tabular data in a relational database and the comparison with the same data structured in a graph,role=popup]

In the relational example, to the left, you need to: 

. Search the `Employees` table (potentially with millions of rows) to find the user Alice and her ID of 815. 
. Search the `Dept_Members` table to locate all the rows that reference Alice's ID of 815.
. Once the 3 relevant rows are found, you go for the `Departments` table to search for the actual values of the department IDs (111, 119, 181).
. Only now you know that Alice is part of the 4Future, P0815, and A42 departments.

In the case of the graph version, you need to:

. Search for Alice's `Employee` nod.
. Traverse all of the `BELONGS_TO` relationships from Alice and find the `Department` nodes she is connected to.

If you want to learn how to create a data model, follow the xref:data-modeling/tutorial-data-modeling.adoc[Tutorial: Create a graph data model] or see how to adapt an existing project with a relational model to a graph on xref:data-modeling/relational-to-graph-modeling.adoc[Modeling: relational to graph].

[#rdbms-graph-query]
== Data storage and retrieval

SQL is the query language used to query relational databases.
xref:cypher.adoc[Cypher] is Neo4j’s declarative query language built on the basic concepts and clauses of SQL, but with additional functionalities that make working with graph databases more efficient.

For example, when writing an SQL statement with a large number of joins, you can quickly lose sight of what the query actually does, since there is a lot of technical noise in SQL syntax.
In Cypher, the syntax remains concise and focused on domain components and their connections, thus expressing the pattern to find or create data more visually and clearly.

Other clauses outside of the basic pattern matching still look very similar to SQL, as Cypher was built on the predecessor language’s foundation. 
You can see the similarities and differences in 
If you want to learn how to move your data from a relational database to a graph, see 

== Keep learning

* xref:/cypher-intro/cypher-sql.adoc[Comparing Cypher with SQL] -> See examples comparing SQL queries with Cypher.
* xref:data-import/relational-to-graph-import.adoc[Import: RDBMS to graph] -> Learn how to import data from a relational database to a graph.
* xref:data-modeling/relational-to-graph-modeling.adoc[Modeling: relational to graph] -> Find more comparisons between relational and graph data modeling.
* https://neo4j.com/resources/rdbms-developer-graph-white-paper/[The Definitive Guide to Graph Databases for the RDBMS Developer] -> Download the free e-book.